defmodule JidoCode.Memory.Types do
  @moduledoc """
  Shared type definitions for the JidoCode memory system.

  This module defines the foundational types used across all memory components,
  including short-term working context, pending memories awaiting promotion,
  and long-term persistent storage.

  ## Memory Type System

  The type system maps directly to the Jido ontology classes, providing semantic
  structure for all memory operations:

  - **memory_type** - Classification of memory items (fact, assumption, hypothesis, etc.)
  - **confidence_level** - Discrete confidence levels (high, medium, low)
  - **source_type** - Origin of the memory (user, agent, tool, external_document)
  - **context_key** - Semantic keys for working context items

  ## Jido Ontology Alignment

  Types in this module correspond to Jido ontology classes:

  | Elixir Type              | Jido Ontology Class           |
  |--------------------------|-------------------------------|
  | `:fact`                  | `jido:Fact`                   |
  | `:assumption`            | `jido:Assumption`             |
  | `:hypothesis`            | `jido:Hypothesis`             |
  | `:discovery`             | `jido:Discovery`              |
  | `:risk`                  | `jido:Risk`                   |
  | `:unknown`               | `jido:Unknown`                |
  | `:decision`              | `jido:Decision`               |
  | `:architectural_decision`| `jido:ArchitecturalDecision`  |
  | `:convention`            | `jido:Convention`             |
  | `:coding_standard`       | `jido:CodingStandard`         |
  | `:lesson_learned`        | `jido:LessonLearned`          |

  ## Confidence Level Mapping

  Confidence levels map to float ranges:

  - `:high` - confidence >= 0.8
  - `:medium` - 0.5 <= confidence < 0.8
  - `:low` - confidence < 0.5

  When converting from level to float, representative values are returned:
  - `:high` -> 0.9
  - `:medium` -> 0.6
  - `:low` -> 0.3
  """

  # =============================================================================
  # Type Definitions
  # =============================================================================

  @typedoc """
  Classification of memory items, mapping to Jido ontology MemoryItem subclasses.

  - `:fact` - Verified, objective information about the project or codebase
  - `:assumption` - Inferred information that may need verification
  - `:hypothesis` - Proposed explanations or theories being tested
  - `:discovery` - Newly found information worth remembering
  - `:risk` - Potential issues or concerns identified
  - `:unknown` - Information gaps that need investigation
  - `:decision` - Choices made with their rationale
  - `:architectural_decision` - Significant architectural choices with rationale
  - `:convention` - Established patterns or standards to follow
  - `:coding_standard` - Specific coding practices and style guidelines
  - `:lesson_learned` - Insights gained from past experiences
  """
  @type memory_type ::
          :fact
          | :assumption
          | :hypothesis
          | :discovery
          | :risk
          | :unknown
          | :decision
          | :architectural_decision
          | :convention
          | :coding_standard
          | :lesson_learned

  @typedoc """
  Discrete confidence levels mapping to Jido ConfidenceLevel individuals.

  - `:high` - High confidence (>= 0.8)
  - `:medium` - Medium confidence (>= 0.5, < 0.8)
  - `:low` - Low confidence (< 0.5)
  """
  @type confidence_level :: :high | :medium | :low

  @typedoc """
  Source of the memory, matching Jido SourceType individuals.

  - `:user` - Information provided directly by the user
  - `:agent` - Information generated by the AI agent
  - `:tool` - Information obtained from tool execution (file reads, commands, etc.)
  - `:external_document` - Information from external documentation or sources
  """
  @type source_type :: :user | :agent | :tool | :external_document

  @typedoc """
  Semantic keys for working context items.

  These keys represent different aspects of session context:

  - `:active_file` - Currently focused file path
  - `:project_root` - Root directory of the project
  - `:primary_language` - Main programming language of the project
  - `:framework` - Primary framework being used (e.g., Phoenix, Rails)
  - `:current_task` - What the user is currently working on
  - `:user_intent` - Inferred goal or objective of the user
  - `:discovered_patterns` - Code patterns found in the project
  - `:active_errors` - Current errors or issues being addressed
  - `:pending_questions` - Unresolved questions or clarifications needed
  - `:file_relationships` - Dependencies or relationships between files
  - `:conversation_summary` - Cached summarized conversation (internal use)
  """
  @type context_key ::
          :active_file
          | :project_root
          | :primary_language
          | :framework
          | :current_task
          | :user_intent
          | :discovered_patterns
          | :active_errors
          | :pending_questions
          | :file_relationships
          | :conversation_summary

  @typedoc """
  A memory item staged for potential promotion to long-term storage.

  ## Fields

  - `id` - Unique identifier for the pending item
  - `content` - The actual content/value of the memory
  - `memory_type` - Classification of this memory
  - `confidence` - Confidence score (0.0 to 1.0)
  - `source_type` - Where this memory originated
  - `evidence` - List of evidence references supporting this memory
  - `rationale` - Optional explanation for why this is worth remembering
  - `suggested_by` - Whether this was implicitly detected or explicitly requested by agent
  - `importance_score` - Calculated importance for promotion decisions
  - `created_at` - When this pending item was created
  - `access_count` - How many times this item has been accessed
  """
  @type pending_item :: %{
          id: String.t(),
          content: String.t(),
          memory_type: memory_type(),
          confidence: float(),
          source_type: source_type(),
          evidence: [String.t()],
          rationale: String.t() | nil,
          suggested_by: :implicit | :agent,
          importance_score: float(),
          created_at: DateTime.t(),
          access_count: non_neg_integer()
        }

  @typedoc """
  An entry in the access log tracking memory/context usage.

  ## Fields

  - `key` - Either a context_key or a memory reference tuple
  - `timestamp` - When the access occurred
  - `access_type` - Type of access (read, write, or query)
  """
  @type access_entry :: %{
          key: context_key() | {:memory, String.t()},
          timestamp: DateTime.t(),
          access_type: :read | :write | :query
        }

  # =============================================================================
  # Helper Functions
  # =============================================================================

  @doc """
  Converts a confidence float value to a discrete confidence level.

  ## Examples

      iex> JidoCode.Memory.Types.confidence_to_level(0.9)
      :high

      iex> JidoCode.Memory.Types.confidence_to_level(0.8)
      :high

      iex> JidoCode.Memory.Types.confidence_to_level(0.7)
      :medium

      iex> JidoCode.Memory.Types.confidence_to_level(0.5)
      :medium

      iex> JidoCode.Memory.Types.confidence_to_level(0.3)
      :low

      iex> JidoCode.Memory.Types.confidence_to_level(0.0)
      :low

  """
  @spec confidence_to_level(float()) :: confidence_level()
  def confidence_to_level(confidence) when confidence >= 0.8, do: :high
  def confidence_to_level(confidence) when confidence >= 0.5, do: :medium
  def confidence_to_level(_confidence), do: :low

  @doc """
  Converts a discrete confidence level to a representative float value.

  Returns representative values for each level:
  - `:high` -> 0.9
  - `:medium` -> 0.6
  - `:low` -> 0.3

  ## Examples

      iex> JidoCode.Memory.Types.level_to_confidence(:high)
      0.9

      iex> JidoCode.Memory.Types.level_to_confidence(:medium)
      0.6

      iex> JidoCode.Memory.Types.level_to_confidence(:low)
      0.3

  """
  @spec level_to_confidence(confidence_level()) :: float()
  def level_to_confidence(:high), do: 0.9
  def level_to_confidence(:medium), do: 0.6
  def level_to_confidence(:low), do: 0.3

  # =============================================================================
  # Type Validation Helpers
  # =============================================================================

  @memory_types [
    :fact,
    :assumption,
    :hypothesis,
    :discovery,
    :risk,
    :unknown,
    :decision,
    :architectural_decision,
    :convention,
    :coding_standard,
    :lesson_learned
  ]

  @confidence_levels [:high, :medium, :low]

  @source_types [:user, :agent, :tool, :external_document]

  @context_keys [
    :active_file,
    :project_root,
    :primary_language,
    :framework,
    :current_task,
    :user_intent,
    :discovered_patterns,
    :active_errors,
    :pending_questions,
    :file_relationships,
    :conversation_summary
  ]

  @doc """
  Returns all valid memory types.
  """
  @spec memory_types() :: [memory_type()]
  def memory_types, do: @memory_types

  @doc """
  Returns all valid confidence levels.
  """
  @spec confidence_levels() :: [confidence_level()]
  def confidence_levels, do: @confidence_levels

  @doc """
  Returns all valid source types.
  """
  @spec source_types() :: [source_type()]
  def source_types, do: @source_types

  @doc """
  Returns all valid context keys.
  """
  @spec context_keys() :: [context_key()]
  def context_keys, do: @context_keys

  @doc """
  Checks if a value is a valid memory type.
  """
  @spec valid_memory_type?(term()) :: boolean()
  def valid_memory_type?(type), do: type in @memory_types

  @doc """
  Checks if a value is a valid confidence level.
  """
  @spec valid_confidence_level?(term()) :: boolean()
  def valid_confidence_level?(level), do: level in @confidence_levels

  @doc """
  Checks if a value is a valid source type.
  """
  @spec valid_source_type?(term()) :: boolean()
  def valid_source_type?(type), do: type in @source_types

  @doc """
  Checks if a value is a valid context key.
  """
  @spec valid_context_key?(term()) :: boolean()
  def valid_context_key?(key), do: key in @context_keys

  # =============================================================================
  # Session ID Validation
  # =============================================================================

  # Maximum session ID length to prevent excessive atom/path creation
  @max_session_id_length 128

  # Pattern for valid session ID characters (alphanumeric, hyphens, underscores)
  @session_id_pattern ~r/\A[a-zA-Z0-9_-]+\z/

  @doc """
  Validates that a session ID is safe for use in atom names and file paths.

  Session IDs must:
  - Be a non-empty string
  - Contain only alphanumeric characters, hyphens, and underscores
  - Be no longer than #{@max_session_id_length} characters

  This prevents:
  - Atom exhaustion attacks (atoms are never garbage collected)
  - Path traversal attacks (e.g., "../../../etc/passwd")

  ## Examples

      iex> Types.valid_session_id?("session-123")
      true

      iex> Types.valid_session_id?("my_session_456")
      true

      iex> Types.valid_session_id?("../../../etc/passwd")
      false

      iex> Types.valid_session_id?("")
      false

  """
  @spec valid_session_id?(term()) :: boolean()
  def valid_session_id?(session_id) when is_binary(session_id) do
    byte_size(session_id) > 0 and
      byte_size(session_id) <= @max_session_id_length and
      Regex.match?(@session_id_pattern, session_id)
  end

  def valid_session_id?(_), do: false

  @doc """
  Returns the maximum allowed session ID length.
  """
  @spec max_session_id_length() :: pos_integer()
  def max_session_id_length, do: @max_session_id_length

  # =============================================================================
  # Session Memory Limits
  # =============================================================================

  # Maximum memories per session to prevent unbounded memory consumption.
  # This protects against runaway agents or malicious actors creating
  # excessive memories that could exhaust system resources.
  @default_max_memories_per_session 10_000

  @doc """
  Returns the default maximum number of memories allowed per session (10,000).

  This limit prevents unbounded memory growth from runaway agents or abuse.
  When exceeded, new memory creation will fail with `:session_memory_limit_exceeded`.
  """
  @spec default_max_memories_per_session() :: pos_integer()
  def default_max_memories_per_session, do: @default_max_memories_per_session

  # =============================================================================
  # Promotion Constants
  # =============================================================================

  @default_promotion_threshold 0.6
  @default_max_promotions_per_run 20

  @doc """
  Returns the default promotion threshold (0.6).

  Items with importance scores at or above this threshold are candidates
  for promotion to long-term storage.
  """
  @spec default_promotion_threshold() :: float()
  def default_promotion_threshold, do: @default_promotion_threshold

  @doc """
  Returns the default maximum promotions per run (20).
  """
  @spec default_max_promotions_per_run() :: pos_integer()
  def default_max_promotions_per_run, do: @default_max_promotions_per_run

  # =============================================================================
  # Utility Functions
  # =============================================================================

  @doc """
  Clamps a numeric value to the unit interval [0.0, 1.0].

  Used for confidence scores, importance scores, and similar bounded values.

  ## Examples

      iex> Types.clamp_to_unit(0.5)
      0.5

      iex> Types.clamp_to_unit(1.5)
      1.0

      iex> Types.clamp_to_unit(-0.3)
      0.0

  """
  @spec clamp_to_unit(number()) :: float()
  def clamp_to_unit(value) when is_number(value) and value < 0.0, do: 0.0
  def clamp_to_unit(value) when is_number(value) and value > 1.0, do: 1.0
  def clamp_to_unit(value) when is_number(value), do: value / 1
end
