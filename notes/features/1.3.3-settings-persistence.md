# Feature: 1.3.3 Settings Persistence

## Problem Statement

JidoCode needs to persist user settings changes to disk:
- Save complete settings to global or local file
- Update individual settings keys
- Add providers/models to allowed lists
- Use atomic writes to prevent file corruption
- Invalidate cache after saves

### Impact Analysis
- **Scope**: Settings persistence for user preferences
- **Dependencies**: Task 1.3.2 (Settings loading/merging) - completed
- **Risk**: Low - standard file operations with atomic write pattern

## Solution Overview

Add save functions to the Settings module using atomic write pattern (write to temp file, then rename). All save operations invalidate the memory cache to ensure consistency.

### Atomic Write Pattern

```elixir
# 1. Write to temp file in same directory
temp_path = path <> ".tmp"
File.write!(temp_path, content)

# 2. Atomic rename (same filesystem = atomic)
File.rename!(temp_path, path)
```

## Technical Details

### File Locations
- `lib/jido_code/settings.ex` - Add save/set/add functions
- `test/jido_code/settings_test.exs` - Add persistence tests

### Key Design Decisions
1. Atomic writes via temp file + rename
2. Cache invalidation after every save
3. `save/2` replaces entire file, `set/3` merges with existing
4. Auto-create directories if they don't exist
5. Pretty-print JSON for human readability

### API Design

```elixir
# Save complete settings to scope
Settings.save(:global, %{"provider" => "anthropic"})
Settings.save(:local, %{"model" => "gpt-4o"})

# Update individual key (merges with existing)
Settings.set(:local, "provider", "openai")
Settings.set(:global, "model", "claude-3-opus")

# Add to provider list
Settings.add_provider(:global, "openrouter")

# Add to model list for provider
Settings.add_model(:local, "anthropic", "claude-3-5-sonnet")
```

## Success Criteria

- [x] `save/2` writes settings to correct file atomically
- [x] `set/3` updates individual keys while preserving others
- [x] `add_provider/2` adds to providers list
- [x] `add_model/3` adds to models map
- [x] Cache is invalidated after every save
- [x] Tests verify round-trip save/load

## Implementation Plan

### Step 1: Implement atomic write helper ✅
- [x] Create `write_atomic/2` private function
- [x] Write to temp file, then rename
- [x] Ensure directory exists before write

### Step 2: Implement save/2 ✅
- [x] Accept scope (:global or :local) and settings map
- [x] Validate settings before save
- [x] Write atomically to appropriate file
- [x] Invalidate cache
- [x] Return :ok or {:error, reason}

### Step 3: Implement set/3 ✅
- [x] Read current settings for scope
- [x] Merge new key/value
- [x] Save merged settings
- [x] Return :ok or {:error, reason}

### Step 4: Implement add_provider/2 ✅
- [x] Read current settings for scope
- [x] Add provider to providers list (dedupe)
- [x] Save updated settings

### Step 5: Implement add_model/3 ✅
- [x] Read current settings for scope
- [x] Add model to models[provider] list (dedupe)
- [x] Save updated settings

### Step 6: Write tests ✅
- [x] Test save creates file
- [x] Test save overwrites existing
- [x] Test set preserves other keys
- [x] Test add_provider adds to list
- [x] Test add_model adds to provider's list
- [x] Test round-trip save/load
- [x] Test cache invalidation

## Current Status

**Status**: ✅ Complete
**Branch**: `feature/1.3.3-settings-persistence`

### What Works
- `save/2` writes settings atomically to global or local file
- `set/3` updates individual keys while preserving others
- `add_provider/2` adds providers to list (with deduplication)
- `add_model/3` adds models to provider's list (with deduplication)
- Atomic writes via temp file + rename pattern
- Cache invalidation after every save
- Pretty-printed JSON output
- 12 new tests, 96 total passing
