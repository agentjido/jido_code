# Feature: 2.2.1 CoT Runner Configuration

**Branch**: `feature/2.2.1-cot-runner-configuration`
**Phase**: Phase 2 - LLM Agent with Chain-of-Thought Reasoning

## Problem Statement

The LLMAgent needs Chain-of-Thought reasoning capabilities for complex coding queries. CoT provides 8-15% accuracy improvement on multi-step reasoning tasks by generating step-by-step reasoning plans before execution.

## Solution Overview

Create `JidoCode.Reasoning.ChainOfThought` wrapper module that:
1. Wraps JidoAI's `Jido.AI.Runner.ChainOfThought` runner
2. Provides `run_with_reasoning/3` for executing queries with CoT
3. Extracts and formats reasoning steps for TUI display
4. Handles fallback to direct execution on reasoning failure
5. Emits telemetry events for monitoring

## Technical Details

### JidoAI CoT API (from research)

```elixir
# Runner configuration
Jido.AI.Runner.ChainOfThought.Config:
  - mode: :zero_shot | :few_shot | :structured (default: :zero_shot)
  - max_iterations: pos_integer() (default: 1)
  - model: String.t() | nil (default: nil - uses agent's model)
  - temperature: float() (default: 0.2)
  - enable_validation: boolean() (default: true)
  - fallback_on_error: boolean() (default: true)

# ReasoningPlan output
%ReasoningPlan{
  goal: String.t(),
  analysis: String.t(),
  steps: [%ReasoningStep{number: int, description: String.t(), expected_outcome: String.t()}],
  expected_results: String.t(),
  potential_issues: [String.t()],
  raw_text: String.t()
}
```

### Files to Create

- `lib/jido_code/reasoning/chain_of_thought.ex` - Main wrapper module
- `test/jido_code/reasoning/chain_of_thought_test.exs` - Tests

### Dependencies

- `Jido.AI.Runner.ChainOfThought` - Core CoT runner
- `Jido.AI.Agent` - Agent for chat execution
- `:telemetry` - For event emission

## Implementation Plan

### Step 1: Create ChainOfThought wrapper module
- [ ] Create `lib/jido_code/reasoning/chain_of_thought.ex`
- [ ] Define module with @moduledoc
- [ ] Define default config constants
- [ ] Define ReasoningResult struct for output

### Step 2: Implement run_with_reasoning/3
- [ ] Accept agent pid, query string, and optional config overrides
- [ ] Build CoT config from defaults + overrides
- [ ] Execute query through JidoAI CoT runner
- [ ] Return structured result with reasoning plan

### Step 3: Add reasoning step extraction
- [ ] Extract ReasoningPlan from runner output
- [ ] Format steps for TUI display
- [ ] Include goal, analysis, steps, expected results

### Step 4: Add fallback to direct execution
- [ ] Detect reasoning failures
- [ ] Fall back to direct chat when CoT fails
- [ ] Log fallback events

### Step 5: Add telemetry events
- [ ] `[:jido_code, :reasoning, :start]` - When reasoning begins
- [ ] `[:jido_code, :reasoning, :complete]` - With duration and step count
- [ ] `[:jido_code, :reasoning, :fallback]` - When falling back to direct

### Step 6: Write tests
- [ ] Test run_with_reasoning with valid query
- [ ] Test config overrides
- [ ] Test fallback behavior
- [ ] Test telemetry emission

### Step 7: Update phase plan
- [ ] Mark task complete in phase-02.md
- [ ] Write summary

## Success Criteria

1. run_with_reasoning/3 executes queries with CoT reasoning
2. Default config uses mode: :zero_shot, temperature: 0.2, enable_validation: true
3. Reasoning steps are extracted and formatted for display
4. Fallback to direct execution works on reasoning failure
5. Telemetry events are emitted for duration and token usage
6. All tests pass

## Current Status

- [x] Step 1: Create ChainOfThought wrapper module
- [x] Step 2: Implement run_with_reasoning/3
- [x] Step 3: Add reasoning step extraction
- [x] Step 4: Add fallback to direct execution
- [x] Step 5: Add telemetry events
- [x] Step 6: Write tests
- [x] Step 7: Update phase plan

## What Works

- `run_with_reasoning/3` - Executes queries with CoT reasoning through LLMAgent
- `default_config/0` - Returns default CoT configuration
- `format_steps_for_display/1` - Formats reasoning steps for TUI display
- `summarize_plan/1` - Returns brief summary of reasoning plan
- Telemetry events for start, complete, fallback, error
- Zero-shot and structured prompt modes
- Automatic fallback to direct execution on failure

## Files Created

- `lib/jido_code/reasoning/chain_of_thought.ex` - Main CoT wrapper module
- `test/jido_code/reasoning/chain_of_thought_test.exs` - 20 tests

## API Examples

```elixir
# Run query with CoT reasoning
{:ok, result} = JidoCode.Reasoning.ChainOfThought.run_with_reasoning(
  agent_pid,
  "How do I implement a GenServer that handles rate limiting?"
)

# Access results
IO.puts(result.response)
IO.puts("Used fallback: #{result.used_fallback}")
IO.puts("Duration: #{result.duration_ms}ms")

# Format steps for display
steps = JidoCode.Reasoning.ChainOfThought.format_steps_for_display(result.reasoning_plan)
Enum.each(steps, &IO.puts/1)

# Get plan summary
summary = JidoCode.Reasoning.ChainOfThought.summarize_plan(result.reasoning_plan)

# Custom config
{:ok, result} = JidoCode.Reasoning.ChainOfThought.run_with_reasoning(
  agent_pid,
  "Debug this code...",
  mode: :structured,
  temperature: 0.3
)
```
