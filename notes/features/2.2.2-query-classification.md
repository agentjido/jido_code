# Feature: 2.2.2 Query Classification

**Branch**: `feature/2.2.2-query-classification`
**Phase**: Phase 2 - LLM Agent with Chain-of-Thought Reasoning

## Problem Statement

The ChainOfThought module needs to intelligently decide when to use CoT reasoning vs direct response. CoT adds 2-3s latency and 3-4x token cost, so it should only be applied to complex queries that benefit from step-by-step reasoning.

## Solution Overview

Create `JidoCode.Reasoning.QueryClassifier` module that:
1. Analyzes query text for complexity indicators
2. Returns boolean for whether CoT should be used
3. Supports force on/off configuration override
4. Achieves 90%+ classification accuracy on test queries

## Technical Details

### Complexity Indicators (Complex = Use CoT)

**Keywords suggesting multi-step reasoning:**
- "debug", "fix", "solve", "troubleshoot"
- "explain", "how does", "why does"
- "step by step", "walk through", "break down"
- "how to", "how do I", "how can I"
- "implement", "create", "build", "design"
- "compare", "difference between"
- "optimize", "improve", "refactor"

**Patterns suggesting complexity:**
- Code blocks (triple backticks)
- Multiple questions (multiple `?`)
- Long queries (>100 characters)
- Error messages or stack traces

### Simplicity Indicators (Simple = Direct Response)

**Simple queries:**
- Greetings: "hi", "hello", "hey", "thanks"
- Single-word queries
- Confirmations: "yes", "no", "ok", "sure"
- Very short queries (<20 characters without keywords)

### Files to Create

- `lib/jido_code/reasoning/query_classifier.ex` - Main classifier module
- `test/jido_code/reasoning/query_classifier_test.exs` - Tests

## Implementation Plan

### Step 1: Create QueryClassifier module
- [ ] Create `lib/jido_code/reasoning/query_classifier.ex`
- [ ] Define module with @moduledoc
- [ ] Define complexity keyword lists
- [ ] Define simplicity patterns

### Step 2: Implement should_use_cot?/1
- [ ] Accept query string
- [ ] Check for force override config
- [ ] Apply classification heuristics
- [ ] Return boolean

### Step 3: Implement classification heuristics
- [ ] Check for simplicity patterns first (fast path)
- [ ] Check for complexity keywords
- [ ] Check for code blocks
- [ ] Check query length
- [ ] Score and threshold

### Step 4: Add force config option
- [ ] Add `classify/2` accepting opts
- [ ] Support `:force_cot` option (true/false/nil)
- [ ] Return forced value when set

### Step 5: Write tests
- [ ] Test simple queries classified correctly
- [ ] Test complex queries classified correctly
- [ ] Test force override works
- [ ] Test edge cases
- [ ] Verify 90%+ accuracy on test set

### Step 6: Update phase plan
- [ ] Mark task complete in phase-02.md
- [ ] Write summary

## Success Criteria

1. should_use_cot?/1 returns boolean based on query analysis
2. Complex queries (debug, explain, how to, code blocks) return true
3. Simple queries (greetings, confirmations, short) return false
4. Force override config works
5. 90%+ accuracy on test queries
6. All tests pass

## Current Status

- [x] Step 1: Create QueryClassifier module
- [x] Step 2: Implement should_use_cot?/1
- [x] Step 3: Implement classification heuristics
- [x] Step 4: Add force config option
- [x] Step 5: Write tests
- [x] Step 6: Update phase plan

## What Works

- `should_use_cot?/1` - Returns boolean based on query complexity
- `classify/2` - Classifies with optional force_cot override
- `analyze/1` - Returns detailed score and reasons for debugging
- Complexity keywords: debug, explain, how to, implement, compare, optimize
- Code block detection (triple backticks)
- Long query detection (>100 chars)
- Multiple question detection
- Simplicity patterns: greetings, confirmations, single words
- 90%+ accuracy on test set (42 complex + 31 simple queries)

## Files Created

- `lib/jido_code/reasoning/query_classifier.ex` - Main classifier module
- `test/jido_code/reasoning/query_classifier_test.exs` - 30 tests

## API Examples

```elixir
# Check if CoT should be used
JidoCode.Reasoning.QueryClassifier.should_use_cot?("How do I implement a GenServer?")
# => true

JidoCode.Reasoning.QueryClassifier.should_use_cot?("hello")
# => false

# Force CoT on/off
JidoCode.Reasoning.QueryClassifier.classify("hello", force_cot: true)
# => true

JidoCode.Reasoning.QueryClassifier.classify("How to X?", force_cot: false)
# => false

# Get detailed analysis
JidoCode.Reasoning.QueryClassifier.analyze("How do I debug this error?")
# => %{score: 2, reasons: ["keyword: debug", "keyword: error"], should_use_cot: true}
```
