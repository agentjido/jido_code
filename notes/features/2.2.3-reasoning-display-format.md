# Feature: 2.2.3 Reasoning Display Format

**Branch**: `feature/2.2.3-reasoning-display-format`
**Phase**: Phase 2 - LLM Agent with Chain-of-Thought Reasoning

## Problem Statement

Chain-of-Thought reasoning produces multi-step reasoning plans that need to be displayed clearly in the TUI. Users need to see reasoning progress with visual status indicators, validation results, and collapsible summaries for long chains.

## Solution Overview

Create `JidoCode.Reasoning.Formatter` module that:
1. Defines Step struct with status tracking
2. Formats reasoning plans with visual separators and structure
3. Provides step status indicators (○ ◐ ● ✗)
4. Formats validation results with confidence scores
5. Supports collapsible summaries for long reasoning chains

## Technical Details

### Step Struct

```elixir
defmodule Formatter.Step do
  @type status :: :pending | :in_progress | :complete | :failed

  @type t :: %__MODULE__{
    number: pos_integer(),
    description: String.t(),
    outcome: String.t() | nil,
    status: status()
  }
end
```

### Status Indicators

- `○` - Pending (not started)
- `◐` - In Progress (currently executing)
- `●` - Complete (finished successfully)
- `✗` - Failed (encountered error)

### Files Created

- `lib/jido_code/reasoning/formatter.ex` - Main formatter module
- `test/jido_code/reasoning/formatter_test.exs` - Tests

## Implementation Plan

### Step 1: Create Formatter module with Step struct
- [x] Create `lib/jido_code/reasoning/formatter.ex`
- [x] Define Step struct with number, description, outcome, status
- [x] Implement `Step.from_map/1` to convert from reasoning plan maps

### Step 2: Implement format_plan/1 function
- [x] Format header with goal and separators
- [x] Format steps section with numbered list
- [x] Format expected results
- [x] Format potential issues with warning indicators
- [x] Support formatting options (indent, show_outcomes, max_description_length)

### Step 3: Add step status indicators
- [x] Define status indicator map
- [x] Implement `format_step/2` with status-appropriate indicators
- [x] Implement `status_indicator/1` for external use

### Step 4: Format validation results
- [x] Implement `format_validation/1`
- [x] Show pass/fail with confidence percentage
- [x] List issues for failed validations

### Step 5: Create collapsible summary
- [x] Implement `format_summary/2`
- [x] Support collapsed view (▶) for long chains
- [x] Support expanded view
- [x] Make collapse_threshold configurable

### Step 6: Write formatter tests
- [x] Test Step struct creation
- [x] Test format_plan/2 with various inputs
- [x] Test format_step/2 with all statuses
- [x] Test format_validation/1
- [x] Test format_summary/2 collapsing behavior
- [x] Test helper functions
- [x] Test output readability

### Step 7: Update phase plan
- [x] Mark task complete in phase-02.md
- [x] Write summary

## Success Criteria

1. Step struct holds number, description, outcome, status
2. format_plan/1 produces human-readable output
3. Status indicators: ○ (pending), ◐ (in_progress), ● (complete), ✗ (failed)
4. Validation results show confidence percentage
5. Collapsible summary for chains > 5 steps
6. All tests pass

## Current Status

- [x] Step 1: Create Formatter module with Step struct
- [x] Step 2: Implement format_plan/1 function
- [x] Step 3: Add step status indicators
- [x] Step 4: Format validation results
- [x] Step 5: Create collapsible summary
- [x] Step 6: Write formatter tests
- [x] Step 7: Update phase plan

## What Works

- `Step.from_map/1` - Creates Step struct from reasoning plan map
- `format_plan/2` - Formats complete reasoning plan with header, steps, expected results
- `format_step/2` - Formats single step with status indicator
- `format_validation/1` - Formats validation results with confidence %
- `format_summary/2` - Creates collapsible/expandable summary
- `status_indicator/1` - Returns indicator character for status
- `steps_from_maps/1` - Batch convert maps to Step structs
- `update_step_status/3` - Update specific step's status
- `step_status_counts/1` - Count steps by status

## Files Created

- `lib/jido_code/reasoning/formatter.ex` - Main formatter module
- `test/jido_code/reasoning/formatter_test.exs` - 51 tests

## API Examples

```elixir
alias JidoCode.Reasoning.Formatter
alias JidoCode.Reasoning.Formatter.Step

# Format a reasoning plan
formatted = Formatter.format_plan(reasoning_plan)
IO.puts(formatted)
# ════════════════════════════════════════════════════════════
# Goal: Implement rate limiting for API endpoints
# ════════════════════════════════════════════════════════════
#
# Steps:
# ○ 1. Analyze current request handling (Understand flow)
# ○ 2. Design rate limiting algorithm (Algorithm chosen)
# ...
# ────────────────────────────────────────────────────────────

# Format a single step
step = %Step{number: 1, description: "Analyze", status: :complete, outcome: "Done"}
Formatter.format_step(step)
# => "● 1. Analyze (Done)"

# Format validation
Formatter.format_validation(%{valid: true, confidence: 0.92, issues: []})
# => "✓ Validation passed (92% confidence)"

# Collapsible summary
Formatter.format_summary(long_plan, expanded: false)
# => "▶ Implement rate limiting (10 steps: 3/10 complete)"

# Get status indicator
Formatter.status_indicator(:in_progress)
# => "◐"
```
