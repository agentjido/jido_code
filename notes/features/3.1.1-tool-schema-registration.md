# Feature 3.1.1: Tool Schema and Registration

## Problem Statement

The LLM agent needs a structured way to discover and invoke tools for interacting with the codebase. This requires:
1. A schema system that defines tools with their parameters and handlers
2. A registry that manages tool registration and lookup
3. LLM-compatible format generation for system prompts

**Impact**: This is foundational infrastructure for Phase 3. Without it, the agent cannot call tools like file read/write, search, or shell execution.

## Solution Overview

Implement a tool schema and registry system following these design principles:
- **Structs for type safety**: `%Tool{}` and `%Param{}` structs with validation
- **GenServer registry**: ETS-backed for fast lookups, GenServer for registration
- **LLM format generation**: OpenAI-compatible function calling JSON schema
- **Validation at registration**: Catch invalid tools early, not at runtime

## Technical Details

### File Structure
```
lib/jido_code/tools/
├── tools.ex           # Namespace module with Tool struct
├── param.ex           # Param struct for parameter definitions
└── registry.ex        # GenServer registry for tool management

test/jido_code/tools/
├── tools_test.exs     # Tool struct tests
├── param_test.exs     # Param struct tests
└── registry_test.exs  # Registry tests
```

### Dependencies
- No new dependencies required
- Uses ETS for storage (built into OTP)

### Tool Schema Design

```elixir
defmodule JidoCode.Tools.Tool do
  @type t :: %__MODULE__{
    name: String.t(),
    description: String.t(),
    parameters: [JidoCode.Tools.Param.t()],
    handler: atom()  # Module that implements execute/2
  }
end

defmodule JidoCode.Tools.Param do
  @type t :: %__MODULE__{
    name: String.t(),
    type: :string | :integer | :boolean | :array | :object,
    description: String.t(),
    required: boolean(),
    default: term() | nil
  }
end
```

### Registry API

```elixir
# Register a tool
Registry.register(%Tool{...})
# => :ok | {:error, reason}

# List all tools
Registry.list()
# => [%Tool{}, ...]

# Get tool by name
Registry.get("read_file")
# => {:ok, %Tool{}} | {:error, :not_found}

# Generate LLM format
Registry.to_llm_format()
# => [%{type: "function", function: %{name: ..., description: ..., parameters: ...}}]
```

## Success Criteria

1. Tool struct validates required fields (name, description, handler)
2. Param struct validates type is one of allowed types
3. Registry starts with supervision tree
4. Tools can be registered and looked up by name
5. Duplicate tool names are rejected
6. LLM format generation produces valid OpenAI function calling schema
7. All tests pass with >90% coverage

## Implementation Plan

### Step 1: Create JidoCode.Tools.Param struct
- [ ] Define struct with fields: name, type, description, required, default
- [ ] Add type validation (allowed types: string, integer, boolean, array, object)
- [ ] Implement `new/1` constructor with validation
- [ ] Implement `to_json_schema/1` for LLM format
- [ ] Write tests

### Step 2: Create JidoCode.Tools.Tool struct
- [ ] Define struct with fields: name, description, parameters, handler
- [ ] Add validation for required fields
- [ ] Implement `new/1` constructor with validation
- [ ] Implement `to_llm_function/1` for LLM format
- [ ] Write tests

### Step 3: Create JidoCode.Tools namespace module
- [ ] Create main module that re-exports Tool and Param
- [ ] Add module documentation

### Step 4: Create JidoCode.Tools.Registry GenServer
- [ ] Implement GenServer with ETS table for storage
- [ ] Implement `register/1` with duplicate detection
- [ ] Implement `list/0` returning all tools
- [ ] Implement `get/1` for lookup by name
- [ ] Implement `to_llm_format/0` for system prompt generation
- [ ] Add to Application supervision tree
- [ ] Write comprehensive tests

### Step 5: Update phase plan and create summary
- [ ] Mark tasks complete in phase-03.md
- [ ] Write summary document

## Current Status

**Status**: Planning Complete
**What Works**: N/A (not started)
**What's Next**: Step 1 - Param struct
**How to Run**: N/A

## Notes

- Handler is an atom (module name) not a function - allows serialization
- Tools will be registered at application startup by tool implementation modules
- LLM format follows OpenAI function calling spec for compatibility
