# Feature 3.1.2: Tool Execution Flow

## Problem Statement

The LLM agent needs to execute tools based on function calls in its response. This requires:
1. Parsing tool calls from LLM JSON responses (OpenAI function calling format)
2. Validating tool names and parameters against the registry
3. Delegating execution to a sandbox manager (not executing directly)
4. Handling timeouts and formatting results for LLM consumption
5. Supporting sequential tool calls where one result feeds into the next

**Impact**: This bridges the LLM's tool call requests with actual execution, enabling the agent to interact with the codebase.

## Solution Overview

Implement a `JidoCode.Tools.Executor` module that:
- Parses OpenAI-style tool calls from LLM responses
- Validates against the Tool Registry (name exists, params valid)
- Delegates to a configurable executor function (for sandbox integration)
- Handles timeouts via Task with configurable limits
- Formats results as tool messages for LLM context
- Supports batch execution with sequential dependency handling

## Technical Details

### File Structure
```
lib/jido_code/tools/
├── executor.ex        # Tool execution coordination
└── result.ex          # Tool result struct for consistent formatting

test/jido_code/tools/
└── executor_test.exs  # Execution flow tests with mocks
```

### OpenAI Tool Call Format (Input)

```json
{
  "tool_calls": [
    {
      "id": "call_abc123",
      "type": "function",
      "function": {
        "name": "read_file",
        "arguments": "{\"path\": \"/src/main.ex\"}"
      }
    }
  ]
}
```

### Tool Result Format (Output)

```json
{
  "role": "tool",
  "tool_call_id": "call_abc123",
  "content": "defmodule Main do..."
}
```

### Executor API

```elixir
# Execute a single tool call
Executor.execute(tool_call, opts)
# => {:ok, %Result{}} | {:error, reason}

# Execute multiple tool calls (sequential or parallel)
Executor.execute_batch(tool_calls, opts)
# => {:ok, [%Result{}]} | {:error, reason}

# Parse tool calls from LLM response
Executor.parse_tool_calls(response)
# => {:ok, [tool_call]} | {:error, :no_tool_calls}
```

### Result Struct

```elixir
defmodule JidoCode.Tools.Result do
  defstruct [
    :tool_call_id,
    :tool_name,
    :status,      # :ok | :error | :timeout
    :content,     # Result content or error message
    :duration_ms
  ]
end
```

## Success Criteria

1. Parse tool calls from OpenAI-format JSON responses
2. Validate tool exists in registry before execution
3. Validate parameters against tool schema
4. Delegate execution to configurable executor (not direct)
5. Handle timeouts gracefully with configurable limit
6. Format results for LLM consumption (tool role messages)
7. Support sequential tool calls
8. All tests pass with mocked executor

## Implementation Plan

### Step 1: Create JidoCode.Tools.Result struct
- [ ] Define struct: tool_call_id, tool_name, status, content, duration_ms
- [ ] Implement `to_llm_message/1` for LLM-compatible format
- [ ] Write tests

### Step 2: Create JidoCode.Tools.Executor module
- [ ] Implement `parse_tool_calls/1` to extract from LLM response
- [ ] Implement `execute/2` for single tool execution
- [ ] Validate tool exists in registry
- [ ] Validate parameters via Tool.validate_args/2
- [ ] Write tests

### Step 3: Add execution delegation
- [ ] Accept executor function in options (for sandbox integration)
- [ ] Default executor calls handler module directly (for testing)
- [ ] Wrap execution in Task for timeout handling
- [ ] Write tests

### Step 4: Add timeout and result formatting
- [ ] Configurable timeout (default 30s)
- [ ] Catch timeout and return error result
- [ ] Format results with duration tracking
- [ ] Write tests

### Step 5: Support batch execution
- [ ] Implement `execute_batch/2` for multiple tool calls
- [ ] Execute sequentially by default
- [ ] Option for parallel execution
- [ ] Write tests

### Step 6: Update phase plan and create summary
- [ ] Mark tasks complete in phase-03.md
- [ ] Write summary document

## Current Status

**Status**: Complete
**What Works**: All features implemented and tested
**What's Next**: Task 3.2 - Lua Sandbox Tool Manager
**How to Run**: `mix test test/jido_code/tools/executor_test.exs test/jido_code/tools/result_test.exs`

## Notes

- Executor does NOT execute tools directly - it delegates to a configurable function
- This allows the Lua sandbox (Task 3.2) to be plugged in later
- For now, default executor calls the handler module's `execute/2` directly
- Tool handlers are not implemented yet - tests will use mocks
