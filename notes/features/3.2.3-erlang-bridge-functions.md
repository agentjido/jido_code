# Feature 3.2.3: Erlang Bridge Functions

## Problem Statement

Lua scripts running in the sandbox need to perform actual operations (file I/O, shell commands, HTTP requests). These operations must be:
1. Exposed to Lua as callable functions
2. Path-validated using the Security module (Task 3.2.2)
3. Executed via controlled Erlang/Elixir code (not Lua native libraries)

**Impact**: Without bridge functions, tools cannot perform any useful work despite having a working Lua sandbox.

## Solution Overview

Create a `JidoCode.Tools.Bridge` module that exposes Elixir functions to Lua. These functions:
- Are registered in the Lua state as `jido.*` namespace
- Validate all paths using `Security.validate_path/3`
- Execute operations via Elixir standard library
- Return results in Lua-compatible format

Bridge functions:
- `jido.read_file(path)` - Read file contents
- `jido.write_file(path, content)` - Write file
- `jido.list_dir(path)` - List directory
- `jido.file_exists(path)` - Check existence
- `jido.shell(command, args)` - Execute shell command
- `jido.http(method, url, opts)` - HTTP request (deferred - not needed for POC)

## Technical Details

### File Structure
```
lib/jido_code/tools/
├── bridge.ex            # NEW - Erlang-Lua bridge functions
├── manager.ex           # Modified - register bridge functions
└── security.ex          # Existing - path validation

test/jido_code/tools/
└── bridge_test.exs      # NEW - Bridge function tests
```

### Bridge Function Signatures

Each bridge function receives:
1. Lua arguments (list)
2. Lua state
3. Project root (for path validation)

Returns: `{[result], new_state}` or raises error

### Luerl Function Registration

```elixir
# Register as Erlang function in Lua
:luerl.set_table_keys(["jido", "read_file"],
  {:erl_mfa, Bridge, :lua_read_file, project_root},
  lua_state)
```

### Shell Execution

Shell commands run via `System.cmd/3` with:
- Working directory set to project root
- Timeout enforcement
- stdout/stderr capture
- Exit code returned

## Success Criteria

1. Bridge functions registered in Lua as `jido.*`
2. File operations validate paths before execution
3. Invalid paths return errors (not crash)
4. Shell commands run in project directory
5. Shell commands respect timeout
6. All tests pass

## Implementation Plan

### Step 1: Create JidoCode.Tools.Bridge module
- [ ] Create module with bridge function implementations
- [ ] Implement `lua_read_file/3` with path validation
- [ ] Implement `lua_write_file/3` with path validation
- [ ] Implement `lua_list_dir/3` with path validation
- [ ] Implement `lua_file_exists/3` with path validation
- [ ] Write tests for file operations

### Step 2: Implement shell bridge
- [ ] Implement `lua_shell/3` using System.cmd
- [ ] Set working directory to project root
- [ ] Capture stdout/stderr
- [ ] Return exit code with output
- [ ] Enforce timeout
- [ ] Write shell tests

### Step 3: Register bridge in Manager
- [ ] Update Manager.init to register bridge functions
- [ ] Pass project_root to bridge functions
- [ ] Test registration works

### Step 4: Integration tests
- [ ] Test Lua scripts calling bridge functions
- [ ] Test path validation blocks bad paths
- [ ] Test shell command execution

### Step 5: Update phase plan and create summary
- [ ] Mark tasks complete in phase-03.md
- [ ] Write summary document

## Current Status

**Status**: Complete
**What Works**: All file operations and shell execution work with path validation
**What's Next**: Task 3.3.1 - File System Tools
**How to Run**: `mix test test/jido_code/tools/bridge_test.exs`

## Notes

- HTTP bridge deferred - not needed for POC, adds complexity
- Bridge functions must handle Lua nil values gracefully
- Error messages should be user-friendly for LLM consumption
- Shell timeout defaults to 60 seconds (configurable)
