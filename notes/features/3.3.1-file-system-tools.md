# Feature 3.3.1: File System Tools

## Problem Statement

The LLM agent needs tools to interact with the codebase file system. These tools must:
1. Follow the Tool/Handler pattern established in Task 3.1
2. Delegate to Bridge functions for sandboxed execution (Task 3.2.3)
3. Return structured results suitable for LLM consumption

**Impact**: Without file system tools, the agent cannot read, write, or navigate the codebase.

## Solution Overview

Create a `JidoCode.Tools.Handlers.FileSystem` module containing handler functions for file operations. Each handler:
- Validates inputs
- Calls the appropriate Bridge function via Manager
- Returns structured `{:ok, result}` or `{:error, reason}` responses

Tools to implement:
- `read_file` - Read file contents
- `write_file` - Write/overwrite file contents
- `list_directory` - List directory contents (with optional recursive)
- `file_info` - Get file metadata (size, type, modified time)
- `create_directory` - Create a directory
- `delete_file` - Delete a file (with confirmation flag)

## Technical Details

### File Structure
```
lib/jido_code/tools/
├── handlers/
│   └── file_system.ex    # NEW - File system tool handlers
├── definitions/
│   └── file_system.ex    # NEW - Tool definitions for registration
├── bridge.ex             # Existing - Erlang-Lua bridge
├── manager.ex            # Existing - Lua sandbox manager
└── ...

test/jido_code/tools/
├── handlers/
│   └── file_system_test.exs  # NEW - Handler tests
└── ...
```

### Handler Pattern

Each handler implements the `execute/2` callback expected by the Executor:

```elixir
def execute(args, context) :: {:ok, result} | {:error, reason}
```

The context map contains:
- `:project_root` - Base directory for operations (from Manager)

### Tool Definitions

Each tool needs:
- Name (string)
- Description (for LLM)
- Parameters (with types, required flags)
- Handler module

### Bridge Integration

Handlers will call Bridge functions directly with project_root from context, not through Manager's Lua execution. This is more direct since we're in Elixir.

## Success Criteria

1. All 6 file tools implemented and registered
2. Tools delegate to Bridge functions for path validation
3. Structured results returned (`{:ok, content}` or `{:error, reason}`)
4. All tests pass
5. Tools work end-to-end with Executor

## Implementation Plan

### Step 1: Create FileSystem handler module
- [x] Create `lib/jido_code/tools/handlers/file_system.ex`
- [x] Implement `execute/2` for read_file
- [x] Implement `execute/2` for write_file
- [x] Implement `execute/2` for list_directory
- [x] Implement `execute/2` for file_info
- [x] Implement `execute/2` for create_directory
- [x] Implement `execute/2` for delete_file

### Step 2: Create tool definitions
- [x] Create `lib/jido_code/tools/definitions/file_system.ex`
- [x] Define read_file tool
- [x] Define write_file tool
- [x] Define list_directory tool
- [x] Define file_info tool
- [x] Define create_directory tool
- [x] Define delete_file tool
- [x] Implement `all/0` to return all file tools

### Step 3: Write tests
- [x] Create handler tests
- [x] Test each operation success case
- [x] Test error cases (missing file, bad path, security)
- [x] Test integration with Executor

### Step 4: Update phase plan
- [ ] Mark tasks complete in phase-03.md
- [ ] Write summary document

## Current Status

**Status**: Complete
**What Works**: All 6 file system tools implemented and tested
**What's Next**: Task 3.3.2 - Search Tools
**How to Run**: `mix test test/jido_code/tools/handlers/file_system_test.exs test/jido_code/tools/definitions/file_system_test.exs`

## Notes

- Handlers call Bridge functions directly, not via Lua scripts
- The `delete_file` tool includes a `confirm` flag for safety
- `list_directory` supports recursive listing via a boolean parameter
- `file_info` returns metadata as a map (size, type, modified)
