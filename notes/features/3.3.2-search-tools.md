# Feature 3.3.2: Search Tools

## Problem Statement

The LLM agent needs tools to search the codebase for patterns and files. These tools must:
1. Follow the Handler/Tool pattern established in Task 3.1
2. Use Security module for path validation (Task 3.2.2)
3. Return structured results suitable for LLM consumption
4. Handle large result sets with truncation

**Impact**: Without search tools, the agent cannot efficiently navigate or understand the codebase structure.

## Solution Overview

Create search tool handlers in `JidoCode.Tools.Handlers.Search` module:

- `grep` - Search file contents for patterns, returns matched lines with file paths and line numbers
- `find_files` - Find files by name/glob pattern, returns list of matching file paths

Both tools will:
- Validate paths using the Security module
- Support recursive searching
- Truncate large result sets (configurable limit)
- Return JSON-formatted results for LLM consumption

## Technical Details

### File Structure
```
lib/jido_code/tools/
├── handlers/
│   ├── file_system.ex    # Existing
│   └── search.ex         # NEW - Search tool handlers
├── definitions/
│   ├── file_system.ex    # Existing
│   └── search.ex         # NEW - Search tool definitions
└── ...

test/jido_code/tools/
├── handlers/
│   ├── file_system_test.exs  # Existing
│   └── search_test.exs       # NEW - Search handler tests
├── definitions/
│   └── search_test.exs       # NEW - Search integration tests
└── ...
```

### Grep Tool Design

Parameters:
- `pattern` (required, string) - Regex or literal pattern to search
- `path` (required, string) - Directory or file to search in
- `recursive` (optional, boolean) - Search subdirectories (default: true)
- `max_results` (optional, integer) - Maximum matches to return (default: 100)

Returns JSON array:
```json
[
  {"file": "src/main.ex", "line": 42, "content": "def hello do"},
  {"file": "src/main.ex", "line": 55, "content": "def hello_world do"}
]
```

### Find Files Tool Design

Parameters:
- `pattern` (required, string) - Glob pattern or filename to find
- `path` (optional, string) - Directory to search in (default: project root)
- `max_results` (optional, integer) - Maximum files to return (default: 100)

Returns JSON array:
```json
["src/main.ex", "lib/helper.ex", "test/main_test.exs"]
```

### Implementation Approach

Use Elixir's built-in capabilities:
- `File.ls/1` and `Path.wildcard/2` for file finding
- `File.stream!/1` for efficient line-by-line reading
- `Regex.match?/2` for pattern matching
- Stream processing to handle large codebases efficiently

## Success Criteria

1. Both search tools implemented and registered
2. Path validation prevents directory traversal
3. Results truncated at configurable limit
4. Line numbers and file paths included in grep results
5. Glob patterns work for find_files
6. All tests pass

## Implementation Plan

### Step 1: Create Search handler module
- [x] Create `lib/jido_code/tools/handlers/search.ex`
- [x] Implement Grep handler with pattern matching
- [x] Implement FindFiles handler with glob support
- [x] Add result truncation with configurable limits

### Step 2: Create tool definitions
- [x] Create `lib/jido_code/tools/definitions/search.ex`
- [x] Define grep tool with all parameters
- [x] Define find_files tool with all parameters
- [x] Implement `all/0` to return search tools

### Step 3: Write tests
- [x] Create handler tests for grep
- [x] Create handler tests for find_files
- [x] Test result truncation
- [x] Test security boundary enforcement
- [x] Test integration with Executor

### Step 4: Update phase plan
- [ ] Mark tasks complete in phase-03.md
- [ ] Write summary document

## Current Status

**Status**: Complete
**What Works**: Both search tools implemented and tested
**What's Next**: Task 3.3.3 - Shell Execution Tool
**How to Run**: `mix test test/jido_code/tools/handlers/search_test.exs test/jido_code/tools/definitions/search_test.exs`

## Notes

- Use streaming for large files to avoid memory issues
- Default max_results of 100 prevents overwhelming the LLM context
- Glob patterns use Elixir's Path.wildcard which supports `**`, `*`, `?`, `[a-z]`
- Regex patterns should handle invalid regex gracefully with error messages
