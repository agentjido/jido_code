# Feature 3.3.3: Shell Execution Tool

## Problem Statement

The LLM agent needs to execute shell commands for tasks like running tests, building projects, and executing scripts. The tool must:
1. Run commands in a controlled environment (project directory)
2. Capture stdout and stderr separately
3. Return exit codes for success/failure detection
4. Enforce execution timeouts to prevent hanging
5. Optionally allow/block specific commands

**Impact**: Without shell execution, the agent cannot run tests, builds, linters, or other development tools.

## Solution Overview

Create a `run_command` tool handler in `JidoCode.Tools.Handlers.Shell` that:
- Executes commands via `System.cmd/3` with proper options
- Runs in project directory (enforced via `cd:` option)
- Captures stdout via command output, stderr via port
- Enforces configurable timeout (default: 60s)
- Returns structured JSON with exit_code, stdout, stderr

## Technical Details

### File Structure
```
lib/jido_code/tools/
├── handlers/
│   ├── file_system.ex    # Existing
│   ├── search.ex         # Existing
│   └── shell.ex          # NEW - Shell execution handler
├── definitions/
│   ├── file_system.ex    # Existing
│   ├── search.ex         # Existing
│   └── shell.ex          # NEW - Shell tool definition
└── ...

test/jido_code/tools/
├── handlers/
│   └── shell_test.exs    # NEW - Shell handler tests
├── definitions/
│   └── shell_test.exs    # NEW - Shell integration tests
└── ...
```

### Run Command Tool Design

Parameters:
- `command` (required, string) - Command to execute
- `args` (optional, array) - Command arguments
- `timeout` (optional, integer) - Timeout in milliseconds (default: 60000)

Returns JSON object:
```json
{
  "exit_code": 0,
  "stdout": "output here...",
  "stderr": ""
}
```

### Implementation Approach

Use Elixir's `System.cmd/3` with options:
- `cd: project_root` - Run in project directory
- `stderr_to_stdout: false` - Keep stderr separate (requires port approach)
- Timeout enforcement via Task with yield/shutdown

Note: `System.cmd/3` doesn't capture stderr separately by default. We'll use a port-based approach or redirect stderr to a temp file for proper capture.

### Stderr Capture Strategy

Option 1: Use `2>&1` redirect and parse (loses stderr distinction)
Option 2: Use Erlang port with separate stderr (complex)
Option 3: Use shell wrapper `sh -c "cmd 2>file"` (filesystem overhead)

For POC, we'll use Option 1 with a note that stderr is merged with stdout, which is acceptable for most LLM use cases.

## Success Criteria

1. run_command tool implemented and registered
2. Commands run in project directory
3. Exit code captured correctly
4. Output captured (stdout, with stderr merged for POC)
5. Timeout enforced with configurable limit
6. All tests pass

## Implementation Plan

### Step 1: Create Shell handler module
- [x] Create `lib/jido_code/tools/handlers/shell.ex`
- [x] Implement RunCommand handler with timeout support
- [x] Capture exit code and output
- [x] Run commands in project directory

### Step 2: Create tool definition
- [x] Create `lib/jido_code/tools/definitions/shell.ex`
- [x] Define run_command tool with all parameters
- [x] Implement `all/0` to return shell tools

### Step 3: Write tests
- [x] Create handler tests for run_command
- [x] Test timeout enforcement
- [x] Test exit code capture
- [x] Test integration with Executor

### Step 4: Update phase plan
- [ ] Mark tasks complete in phase-03.md
- [ ] Write summary document

## Current Status

**Status**: Complete
**What Works**: run_command tool with timeout, exit code capture, and output
**What's Next**: Task 3.4.1 - Tool Call Display
**How to Run**: `mix test test/jido_code/tools/handlers/shell_test.exs test/jido_code/tools/definitions/shell_test.exs`

## Notes

- Stderr is merged with stdout for POC simplicity
- Timeout default is 60 seconds (configurable)
- Commands execute in project root directory
- Empty env passed to prevent leaking sensitive environment variables
- Command allowlist/blocklist deferred to future enhancement
