# Feature 3.4.1: Tool Call Display

## Problem Statement

When the LLM agent executes tools, users have no visibility into what operations are being performed. This creates a "black box" experience where users must wait without understanding what's happening. Tool transparency is essential for:

1. Debugging - seeing which tools are called and with what parameters
2. Trust - users can verify the agent isn't performing unexpected operations
3. Context - understanding why certain results are produced

**Impact**: Without tool call visibility, users cannot effectively monitor, debug, or trust the agent's operations.

## Solution Overview

Implement PubSub broadcasting of tool call events from the Executor module, along with a formatting module to prepare tool calls for display. The actual TUI rendering will be implemented in Phase 4, but this task prepares all the infrastructure and formatting logic.

### Design Decisions

1. **PubSub Events**: Broadcast events to `"tui.events.{session_id}"` topic (same pattern as LLMAgent)
2. **Event Types**:
   - `{:tool_call, tool_name, params, call_id}` - when tool is invoked
   - `{:tool_result, result}` - when tool completes (includes full Result struct)
3. **Formatting Module**: Create `JidoCode.Tools.Display` for formatting tool calls and results for human consumption
4. **Truncation**: Long content (>500 chars) is truncated with "[...]" suffix for display

## Implementation Plan

### Step 1: Create Tool Display Formatter ✓
- [x] 1.1 Create `JidoCode.Tools.Display` module
- [x] 1.2 Implement `format_tool_call/3` for formatting tool invocation
- [x] 1.3 Implement `format_tool_result/1` for formatting Result struct
- [x] 1.4 Implement `format_params/1` for condensed parameter display
- [x] 1.5 Implement `truncate_content/2` for limiting long content
- [x] 1.6 Add syntax detection for code content highlighting hints

### Step 2: Add PubSub Broadcasting to Executor ✓
- [x] 2.1 Add `broadcast_tool_call/4` function in Executor
- [x] 2.2 Add `broadcast_tool_result/2` function in Executor
- [x] 2.3 Integrate broadcasts into `execute/2` function
- [x] 2.4 Accept optional `:session_id` in executor opts for topic routing
- [x] 2.5 Default to global "tui.events" topic when no session_id provided

### Step 3: Write Tests ✓
- [x] 3.1 Write Display module tests for formatting (30 tests)
- [x] 3.2 Write Executor broadcast tests using PubSub.subscribe (8 tests)
- [x] 3.3 Test truncation behavior
- [x] 3.4 Test error result formatting

### Step 4: Documentation and Finalization ✓
- [x] 4.1 Update phase-03.md with completed task
- [x] 4.2 Write summary document

## Technical Details

### File Structure
```
lib/jido_code/tools/
├── display.ex          # NEW - Tool call formatting
├── executor.ex         # MODIFIED - Add PubSub broadcasts
└── ...

test/jido_code/tools/
├── display_test.exs    # NEW - Display formatting tests
└── executor_test.exs   # MODIFIED - Add broadcast tests
```

### Event Message Format

```elixir
# Tool call event (broadcast when tool execution starts)
{:tool_call, tool_name, params, call_id}
# Example: {:tool_call, "read_file", %{"path" => "src/main.ex"}, "call_abc123"}

# Tool result event (broadcast when tool execution completes)
{:tool_result, %Result{
  tool_call_id: "call_abc123",
  tool_name: "read_file",
  status: :ok | :error | :timeout,
  content: "...",
  duration_ms: 45
}}
```

### Display Format Examples

```
# Tool call display
⚙ read_file(path: "src/main.ex")

# Tool result display (success)
✓ read_file [45ms]: defmodule Main do...

# Tool result display (error)
✗ read_file [12ms]: File not found: src/missing.ex

# Tool result display (timeout)
⏱ slow_operation [30000ms]: Tool execution timed out
```

## Success Criteria

1. Tool calls broadcast `{:tool_call, ...}` events via PubSub
2. Tool results broadcast `{:tool_result, ...}` events via PubSub
3. Display module formats tool calls and results for human consumption
4. Long content is truncated appropriately
5. All tests pass

## TUI Integration (Phase 2 - Current Work)

Now that the TUI exists (Phase 4.1-4.2), we implement the rendering of tool calls.

### Step 5: TUI Model Extensions ✅
- [x] 5.1 Add `tool_calls` field to Model (list of tool call entries)
- [x] 5.2 Add `show_tool_details` field to Model (boolean toggle)
- [x] 5.3 Define `tool_call_entry` type (call_id, tool_name, params, result, timestamp)

### Step 6: TUI Message Handling ✅
- [x] 6.1 Handle `{:tool_call, tool_name, params, call_id}` in update/2
- [x] 6.2 Handle `{:tool_result, result}` in update/2
- [x] 6.3 Match result to pending call by tool_call_id
- [x] 6.4 Add `:toggle_tool_details` message type

### Step 7: Event to Message Mapping ✅
- [x] 7.1 Add Ctrl+T → `:toggle_tool_details` in event_to_msg/2
- [x] 7.2 Handle plain 't' key for regular input

### Step 8: Tool Call Rendering ✅
- [x] 8.1 Create `render_tool_call_line/1` with dimmed styling and "⚙" prefix
- [x] 8.2 Create `render_tool_result_lines/2` with status-based styling
- [x] 8.3 Integrate tool calls into conversation area via `format_tool_call_entry/2`
- [x] 8.4 Add truncation with "[...]" for long content when show_details is false
- [x] 8.5 Show full details when show_tool_details is true

### Step 9: Status Bar Updates ✅
- [x] 9.1 Add "Ctrl+T: Tools" / "Ctrl+T: Hide" hint to status bar

### Step 10: Tests ✅
- [x] 10.1 Test tool_call message handling
- [x] 10.2 Test tool_result message handling
- [x] 10.3 Test result matching to pending call
- [x] 10.4 Test Ctrl+T toggle
- [x] 10.5 Test format_tool_call_entry styling
- [x] 10.6 Test render_tool_result with success/error/timeout
- [x] 10.7 Test truncation behavior
- [x] 10.8 Test status bar hints

## Current Status

**Status**: Complete
**What Works**: Full tool call display in TUI with PubSub integration
**Tests**: 150 tests, 0 failures (26 new tests for tool display)
**How to Run**: `mix test test/jido_code/tui_test.exs`

## Notes

- Infrastructure (Steps 1-4) was completed previously
- TUI integration (Steps 5-10) is the current work
- Use existing `Display` module functions for formatting
