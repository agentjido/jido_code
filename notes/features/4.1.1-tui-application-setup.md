# Feature 4.1.1: TUI Application Module Setup

## Problem Statement

The JidoCode application needs a terminal user interface (TUI) to provide an interactive experience for users. Currently there is no TUI - just backend infrastructure for tools, agents, and settings. Users need a visual interface to:

1. Enter prompts and interact with the LLM agent
2. See agent responses and conversation history
3. View current configuration (provider, model)
4. Monitor agent status (idle, processing, error)

**Impact**: Without a TUI, users cannot interact with the application interactively.

## Solution Overview

Implement the main TUI module using TermUI's Elm Architecture pattern. This task focuses on the foundational setup:

1. Create `JidoCode.TUI` module implementing `TermUI.Elm` behaviour
2. Define the Model struct with necessary state fields
3. Implement `init/1` to initialize state from settings
4. Subscribe to PubSub for agent events
5. Configure the TUI runtime in the application supervisor

### Design Decisions

1. **Elm Architecture**: Use `use TermUI.Elm` for predictable state management
2. **Model Struct**: Define fields for input buffer, messages, agent status, config, reasoning steps
3. **PubSub Integration**: Subscribe to `"tui.events"` topic for agent events
4. **Settings Integration**: Load provider/model from `JidoCode.Settings` on init
5. **Supervisor Integration**: Add TUI runtime to application supervision tree

## Implementation Plan

### Step 1: Create JidoCode.TUI Module ✓
- [x] 1.1 Create `lib/jido_code/tui.ex` with `use TermUI.Elm`
- [x] 1.2 Import necessary TermUI helpers
- [x] 1.3 Define message types as module constants

### Step 2: Define Model Struct ✓
- [x] 2.1 Define `%Model{}` struct with fields:
  - `input_buffer` - current text being typed
  - `messages` - list of conversation messages
  - `agent_status` - :idle, :processing, :error, :unconfigured
  - `config` - map with provider, model keys
  - `reasoning_steps` - list of CoT steps
  - `window` - terminal dimensions {width, height}
- [x] 2.2 Add typespecs for Model struct

### Step 3: Implement init/1 ✓
- [x] 3.1 Load settings via `Settings.load/0`
- [x] 3.2 Extract provider and model from settings
- [x] 3.3 Subscribe to PubSub topic `"tui.events"`
- [x] 3.4 Return initial Model with empty state and loaded config
- [x] 3.5 Determine initial agent_status based on config presence

### Step 4: Implement Minimal update/2 and view/1 ✓
- [x] 4.1 Implement `update/2` that returns unchanged state (placeholder)
- [x] 4.2 Implement `view/1` that renders minimal UI (placeholder)
- [x] 4.3 Add `run/0` function to start runtime

### Step 5: Configure Application Supervisor ✓
- [x] 5.1 Document TUI runtime usage in Application supervisor
- [x] 5.2 TUI not auto-started (allows tests to run without TUI)
- [x] 5.3 TUI started via `JidoCode.TUI.run/0` when needed

### Step 6: Write Tests ✓
- [x] 6.1 Test Model struct creation and defaults
- [x] 6.2 Test init/1 loads settings correctly
- [x] 6.3 Test init/1 subscribes to PubSub
- [x] 6.4 Test agent_status determination based on config

### Step 7: Documentation and Finalization ✓
- [x] 7.1 Update phase-04.md with completed task
- [x] 7.2 Write summary document

## Technical Details

### File Structure
```
lib/jido_code/
├── tui.ex                  # NEW - Main TUI module
└── application.ex          # MODIFIED - Add TUI to supervisor

test/jido_code/
└── tui_test.exs            # NEW - TUI unit tests
```

### Model Struct Definition

```elixir
defmodule JidoCode.TUI.Model do
  @type t :: %__MODULE__{
    input_buffer: String.t(),
    messages: [message()],
    agent_status: :idle | :processing | :error | :unconfigured,
    config: %{provider: String.t() | nil, model: String.t() | nil},
    reasoning_steps: [reasoning_step()],
    window: {non_neg_integer(), non_neg_integer()}
  }

  @type message :: %{
    role: :user | :assistant | :system,
    content: String.t(),
    timestamp: DateTime.t()
  }

  @type reasoning_step :: %{
    step: String.t(),
    status: :pending | :active | :complete
  }
end
```

### PubSub Topics

- `"tui.events"` - Global TUI events topic
- `"tui.events.{session_id}"` - Session-specific events (future)

### Configuration Check

```elixir
def determine_status(config) do
  cond do
    is_nil(config.provider) -> :unconfigured
    is_nil(config.model) -> :unconfigured
    true -> :idle
  end
end
```

## Success Criteria

1. `JidoCode.TUI` module exists and compiles
2. Model struct defined with all required fields
3. `init/1` loads settings and subscribes to PubSub
4. TUI runtime can be started via `JidoCode.TUI.run/0`
5. Application supervisor includes TUI configuration
6. All tests pass

## Current Status

**Status**: Complete
**What Works**: TUI module with Elm Architecture, Model struct, init/1 with settings and PubSub
**What's Next**: Task 4.1.2 Event Handling
**How to Run**: `mix test test/jido_code/tui_test.exs`

## Notes

- The TUI runtime is only started in interactive mode, not during tests
- Event handling (4.1.2) and view rendering (4.2.x) will be separate tasks
- This task focuses on the foundational module setup only
