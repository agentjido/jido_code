# Feature: 4.1.2 TUI Event Handling

## Problem Statement

Task 4.1.2 requires implementing the `event_to_msg/2` callback and `update/2` function for handling user input and agent events. This enables the TUI to respond to keyboard input and update state accordingly.

## Solution Overview

Implement event handling in `JidoCode.TUI` that:
1. Maps terminal events to domain-specific messages via `event_to_msg/2`
2. Handles messages and updates state via `update/2`
3. Uses `TermUI.Command.quit/1` to exit the application

### API Reference (TermUI Events)

```elixir
# Event.Key struct fields
%TermUI.Event.Key{
  key: atom(),           # :enter, :backspace, :up, :down, etc.
  char: String.t() | nil, # printable character or nil
  modifiers: [atom()],   # [:ctrl], [:shift], [:alt]
  timestamp: integer()
}

# event_to_msg/2 return values
{:msg, message}  # Convert event to message
:ignore          # Event not handled
:propagate       # Pass to parent component

# update/2 return values
{state, [commands]}  # New state with commands
{state}              # New state, no commands
:noreply             # Keep state unchanged
```

## Implementation Plan

### Step 1: Define Message Types
- [x] 1.1 Define message types in module (doc comments)

Message types:
- `{:key_input, char}` - Printable character typed
- `{:key_input, :backspace}` - Backspace pressed
- `:submit` - Enter key pressed (submit input)
- `:quit` - Ctrl+C pressed (exit application)
- `{:resize, width, height}` - Terminal resized

### Step 2: Implement event_to_msg/2
- [x] 2.1 Handle Enter key → `:submit`
- [x] 2.2 Handle Backspace → `{:key_input, :backspace}`
- [x] 2.3 Handle Ctrl+C → `:quit`
- [x] 2.4 Handle printable characters → `{:key_input, char}`
- [x] 2.5 Handle Resize event → `{:resize, width, height}`
- [x] 2.6 Return `:ignore` for unhandled events

### Step 3: Implement update/2
- [x] 3.1 Handle `:submit` - add user message, clear buffer
- [x] 3.2 Handle `{:key_input, char}` - append to buffer
- [x] 3.3 Handle `{:key_input, :backspace}` - remove last char
- [x] 3.4 Handle `:quit` - return Command.quit()
- [x] 3.5 Handle `{:resize, w, h}` - update window dimensions

### Step 4: Write Tests
- [x] 4.1 Test event_to_msg/2 for Enter key
- [x] 4.2 Test event_to_msg/2 for Backspace
- [x] 4.3 Test event_to_msg/2 for Ctrl+C
- [x] 4.4 Test event_to_msg/2 for printable characters
- [x] 4.5 Test event_to_msg/2 for Resize
- [x] 4.6 Test event_to_msg/2 returns :ignore for unknown
- [x] 4.7 Test update/2 for :submit
- [x] 4.8 Test update/2 for key_input char
- [x] 4.9 Test update/2 for key_input backspace
- [x] 4.10 Test update/2 for :quit returns Command.quit()
- [x] 4.11 Test update/2 for resize

### Step 5: Verify
- [x] 5.1 Run `mix compile` successfully
- [x] 5.2 Run `mix test` - all tests pass

## Technical Notes

### Event Matching Patterns

```elixir
# Enter key
%Event.Key{key: :enter} -> {:msg, :submit}

# Backspace
%Event.Key{key: :backspace} -> {:msg, {:key_input, :backspace}}

# Ctrl+C
%Event.Key{key: :c, modifiers: [:ctrl]} -> {:msg, :quit}

# Printable character (char is not nil)
%Event.Key{char: char} when is_binary(char) and char != "" ->
  {:msg, {:key_input, char}}

# Resize
%Event.Resize{width: w, height: h} -> {:msg, {:resize, w, h}}
```

### Message Handling

```elixir
# Submit - add message to history
def update(:submit, state) do
  if state.input_buffer != "" do
    message = %{role: :user, content: state.input_buffer, timestamp: DateTime.utc_now()}
    new_state = %{state | input_buffer: "", messages: state.messages ++ [message]}
    {new_state, []}
  else
    {state, []}
  end
end

# Quit - return Command.quit()
def update(:quit, state) do
  {state, [Command.quit(:user_requested)]}
end
```

## Success Criteria

1. `event_to_msg/2` correctly maps all keyboard events
2. `update/2` correctly updates state for all messages
3. Input buffer updates correctly when typing
4. Ctrl+C triggers application quit
5. All tests pass

## Current Status

**Status**: Complete
