# Feature 4.1.3: PubSub Integration

## Problem Statement

The TUI needs to receive real-time updates from the agent system. While basic PubSub message handling was added in task 4.1.2, this task completes the integration by:

1. Ensuring proper message naming conventions match the phase plan
2. Adding message queueing for rapid updates to prevent UI flooding
3. Writing comprehensive integration tests

**Impact**: Without proper PubSub integration, the TUI cannot display agent responses, status changes, or reasoning steps in real-time.

## Solution Overview

### Current State (from 4.1.2)

The following is already implemented:
- PubSub subscription to `"tui.events"` in init/1
- Basic handlers for `{:agent_response, content}`, `{:status_update, status}`, `{:config_change, config}`, `{:reasoning_step, step}`

### What This Task Adds

1. **Message Name Alignment**: Ensure message names match phase plan exactly
2. **Message Queueing**: Add a message queue to handle rapid updates gracefully
3. **Integration Tests**: Comprehensive tests for PubSub message flow

### Message Conventions

Per the phase plan, these are the expected message formats:
- `{:agent_response, content}` - Agent response text
- `{:agent_status, status}` - Status change (idle/processing/error)
- `{:reasoning_step, step}` - CoT step with status
- `{:config_changed, config}` - Configuration change notification

Current implementation uses `{:status_update, status}` and `{:config_change, config}` - need to support both for flexibility.

## Implementation Plan

### Step 1: Add Message Name Aliases
- [x] 1.1 Add handler for `{:agent_status, status}` as alias for status_update
- [x] 1.2 Add handler for `{:config_changed, config}` as alias for config_change
- [x] 1.3 Update message type spec to include aliases

### Step 2: Implement Message Queueing
- [x] 2.1 Add `message_queue` field to Model struct
- [x] 2.2 Add `max_queue_size` constant (default: 100)
- [x] 2.3 Implement queue management in update handlers
- [x] 2.4 Add `clear_reasoning_steps` message for resetting CoT display

### Step 3: Write Integration Tests
- [x] 3.1 Test PubSub subscription verification
- [x] 3.2 Test agent_response updates messages list
- [x] 3.3 Test agent_status updates status field
- [x] 3.4 Test reasoning_step accumulation
- [x] 3.5 Test config_changed updates config and status
- [x] 3.6 Test rapid message handling with queue

### Step 4: Documentation
- [x] 4.1 Update phase-04.md with completed task
- [x] 4.2 Write summary document

## Technical Details

### Message Queue Design

For rapid updates, we'll track recent messages to prevent UI flooding:

```elixir
defstruct ...
  message_queue: [],  # Recent PubSub messages for debugging
  ...

@max_queue_size 100

def update({:agent_response, content}, state) do
  message = %{role: :assistant, content: content, timestamp: DateTime.utc_now()}
  queue = queue_message(state.message_queue, {:agent_response, content})
  new_state = %{state |
    messages: state.messages ++ [message],
    message_queue: queue
  }
  {new_state, []}
end

defp queue_message(queue, msg) do
  [{msg, DateTime.utc_now()} | queue]
  |> Enum.take(@max_queue_size)
end
```

### Test Structure

```elixir
describe "PubSub integration" do
  test "agent_response adds assistant message"
  test "agent_status updates status field"
  test "reasoning_step accumulates steps"
  test "config_changed updates config and recalculates status"
  test "message queue limits size on rapid updates"
end
```

## Success Criteria

1. All PubSub message types handled correctly
2. Message queue prevents unbounded growth
3. Integration tests verify end-to-end message flow
4. All tests pass
5. Credo checks pass

## Current Status

**Status**: Complete
**What Works**: Full PubSub integration with message queueing
**What's Next**: Task 4.2.1 Main Layout Structure
**How to Run**: `mix test test/jido_code/tui_test.exs`
