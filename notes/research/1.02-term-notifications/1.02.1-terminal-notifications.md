# Implementing cross-platform notifications in Elixir

Elixir applications can deliver task completion notifications through two complementary channels: **terminal-level alerts** (bell, window flash) and **system-level notifications** (OS notification center). No native Elixir libraries exist for desktop notifications, so the most practical approach is shelling out via `System.cmd/3` to platform-specific tools—a pattern that works reliably and adds zero dependencies.

## Terminal notifications work everywhere with minimal code

The simplest notification mechanism is the **ASCII BEL character** (`\a` or `\x07`), which triggers terminal bells or visual flashes across virtually all terminal emulators:

```elixir
# Universal terminal bell - works everywhere
IO.write("\a")
```

How terminals respond to BEL varies by configuration. Most support both audible and visual modes—**Windows Terminal** offers the most granular control with its `bellStyle` setting (`"audible"`, `"visual"`, `"window"`, `"taskbar"`, or `"all"`), while **iTerm2** and **Kitty** default to dock/taskbar integration.

### Terminal-specific escape sequences add richer alerts

Beyond the basic bell, several terminals support **OSC escape sequences** for enhanced notifications:

| Terminal | Sequence | Effect |
|----------|----------|--------|
| iTerm2 | `\e]9;message\a` | Posts to Notification Center |
| iTerm2 | `\e]1337;RequestAttention=once\a` | Bounces dock icon once |
| Kitty | `\e]99;i=1:d=1:p=body;message\e\\` | Desktop notification |
| VTE-based (Fedora) | `\e]777;notify;title;body\a` | Desktop notification |

```elixir
defmodule TerminalNotify do
  @doc "Ring terminal bell (universal)"
  def bell, do: IO.write("\a")
  
  @doc "iTerm2 notification center message"
  def iterm_notify(message), do: IO.write("\e]9;#{message}\a")
  
  @doc "iTerm2 dock bounce - modes: yes, once, no, fireworks"
  def iterm_bounce(mode \\ "once"), do: IO.write("\e]1337;RequestAttention=#{mode}\a")
  
  @doc "Kitty desktop notification"
  def kitty_notify(title, body) do
    IO.write("\e]99;i=1:d=0:p=title;#{title}\e\\")
    IO.write("\e]99;i=1:d=1:p=body;#{body}\e\\")
  end
  
  @doc "Set terminal window/tab title"
  def set_title(title), do: IO.write("\e]0;#{title}\a")
end
```

## Detecting terminal and OS at runtime enables smart dispatch

Elixir provides `:os.type/0` for OS detection and environment variables reveal the terminal emulator:

```elixir
defmodule Platform do
  @doc "Returns :macos, :linux, :windows, or :other"
  def os do
    case :os.type() do
      {:unix, :darwin} -> :macos
      {:unix, _}       -> :linux
      {:win32, _}      -> :windows
      _                -> :other
    end
  end
  
  @doc "Detects terminal emulator from environment"
  def terminal do
    cond do
      System.get_env("ITERM_SESSION_ID")  -> :iterm2
      System.get_env("KITTY_WINDOW_ID")   -> :kitty
      System.get_env("WT_SESSION")        -> :windows_terminal
      System.get_env("TERM_PROGRAM") == "Apple_Terminal" -> :apple_terminal
      System.get_env("TMUX")              -> :tmux
      System.get_env("GNOME_TERMINAL_SCREEN") -> :gnome_terminal
      System.get_env("KONSOLE_VERSION")   -> :konsole
      true                                -> :unknown
    end
  end
  
  @doc "Check if stdout is a TTY"
  def tty? do
    case :io.getopts(:standard_io) do
      {:ok, opts} -> Keyword.get(opts, :terminal, false)
      _ -> false
    end
  end
end
```

## macOS system notifications via osascript or terminal-notifier

### The built-in approach uses AppleScript

macOS includes `osascript` which executes AppleScript commands—no installation required:

```elixir
defmodule MacOSNotify do
  @doc "Send notification via osascript (built-in, no dependencies)"
  def notify(message, opts \\ []) do
    title = Keyword.get(opts, :title, "Elixir")
    subtitle = Keyword.get(opts, :subtitle)
    sound = Keyword.get(opts, :sound)  # e.g., "Glass", "Ping", "default"
    
    script = ~s(display notification "#{escape(message)}" with title "#{escape(title)}")
    script = if subtitle, do: script <> ~s( subtitle "#{escape(subtitle)}"), else: script
    script = if sound, do: script <> ~s( sound name "#{sound}"), else: script
    
    System.cmd("osascript", ["-e", script], stderr_to_stdout: true)
  end
  
  defp escape(str), do: String.replace(str, "\"", "\\\"")
end
```

**Limitations**: osascript notifications cannot include custom icons, action buttons, or click callbacks. The notification appears under "Script Editor" in System Preferences.

### terminal-notifier adds rich features when installed

For applications needing click actions, custom icons, or notification grouping, **terminal-notifier** (`brew install terminal-notifier`) provides a more capable alternative:

```elixir
defmodule TerminalNotifierMac do
  @doc "Send notification via terminal-notifier (requires install)"
  def notify(message, opts \\ []) do
    case System.find_executable("terminal-notifier") do
      nil -> {:error, :not_installed}
      path ->
        args = ["-message", message] ++ build_args(opts)
        System.cmd(path, args, stderr_to_stdout: true)
    end
  end
  
  defp build_args(opts) do
    Enum.flat_map(opts, fn
      {:title, v}    -> ["-title", v]
      {:subtitle, v} -> ["-subtitle", v]
      {:sound, v}    -> ["-sound", v]
      {:open, url}   -> ["-open", url]      # Opens URL on click
      {:execute, cmd} -> ["-execute", cmd]  # Runs command on click
      {:group, id}   -> ["-group", id]      # For replacing/removing
      {:sender, id}  -> ["-sender", id]     # Fake sender app (uses its icon)
      _ -> []
    end)
  end
  
  @doc "Remove notification by group ID"
  def remove(group_id) do
    case System.find_executable("terminal-notifier") do
      nil -> {:error, :not_installed}
      path -> System.cmd(path, ["-remove", group_id])
    end
  end
end
```

## Linux uses notify-send with D-Bus underneath

The `notify-send` command from **libnotify** is the standard approach for Linux desktop notifications. It's pre-installed on most distributions or available via package managers (`apt install libnotify-bin`):

```elixir
defmodule LinuxNotify do
  @doc "Send notification via notify-send"
  def notify(title, body, opts \\ []) do
    case System.find_executable("notify-send") do
      nil -> {:error, :not_installed}
      path ->
        args = build_args(title, body, opts)
        System.cmd(path, args, stderr_to_stdout: true)
    end
  end
  
  defp build_args(title, body, opts) do
    base = [title, body]
    
    Enum.reduce(opts, base, fn
      {:urgency, level}, acc -> ["--urgency=#{level}" | acc]  # low, normal, critical
      {:icon, path}, acc     -> ["--icon=#{path}" | acc]
      {:timeout, ms}, acc    -> ["--expire-time=#{ms}" | acc]  # Ignored by GNOME!
      {:app_name, name}, acc -> ["--app-name=#{name}" | acc]
      {:action, {key, label}}, acc -> ["--action=#{key}=#{label}" | acc]
      _, acc -> acc
    end)
  end
end
```

**Desktop environment quirks**: GNOME Shell ignores the `--expire-time` parameter entirely—notifications auto-dismiss based on system settings. Critical urgency notifications typically require manual dismissal across all desktop environments.

For KDE-specific deployments, `kdialog` offers native integration:

```elixir
def kde_notify(message, timeout_secs \\ 5) do
  System.cmd("kdialog", ["--passivepopup", message, "#{timeout_secs}"])
end
```

## Windows requires PowerShell for toast notifications

Windows 10/11 toast notifications work through PowerShell and the Windows Runtime APIs. The **native approach** requires no additional modules:

```elixir
defmodule WindowsNotify do
  @doc "Send Windows toast notification via PowerShell"
  def notify(title, body, _opts \\ []) do
    script = """
    [Windows.UI.Notifications.ToastNotificationManager, Windows.UI.Notifications, ContentType = WindowsRuntime] | Out-Null
    [Windows.Data.Xml.Dom.XmlDocument, Windows.Data.Xml.Dom.XmlDocument, ContentType = WindowsRuntime] | Out-Null
    $xml = @"
    <toast>
      <visual>
        <binding template="ToastGeneric">
          <text>#{escape(title)}</text>
          <text>#{escape(body)}</text>
        </binding>
      </visual>
    </toast>
    "@
    $doc = [Windows.Data.Xml.Dom.XmlDocument]::New()
    $doc.LoadXml($xml)
    $toast = [Windows.UI.Notifications.ToastNotification]::new($doc)
    [Windows.UI.Notifications.ToastNotificationManager]::CreateToastNotifier('PowerShell').Show($toast)
    """
    
    System.cmd("powershell", ["-NoProfile", "-ExecutionPolicy", "Bypass", "-Command", script],
      stderr_to_stdout: true)
  end
  
  defp escape(str), do: String.replace(str, "'", "''")
end
```

For richer notifications with buttons and images, the **BurntToast** PowerShell module (`Install-Module -Name BurntToast`) simplifies the API:

```elixir
def burnttoast_notify(title, body) do
  System.cmd("powershell", [
    "-NoProfile", "-Command",
    "New-BurntToastNotification -Text '#{escape(title)}', '#{escape(body)}'"
  ])
end
```

## Complete cross-platform notification module

Here's a production-ready module that combines all approaches with proper error handling:

```elixir
defmodule Notifier do
  @moduledoc """
  Cross-platform desktop and terminal notifications for Elixir applications.
  Falls back gracefully when notification tools aren't available.
  """
  
  # ============ PUBLIC API ============
  
  @doc "Send both terminal and system notification"
  def notify(title, body, opts \\ []) do
    # Terminal notification (fast, always works)
    terminal_notify(title, body, opts)
    
    # System notification (may fail if tools missing)
    system_notify(title, body, opts)
  end
  
  @doc "Terminal-only notification (bell + terminal-specific)"
  def terminal_notify(title, body, opts \\ []) do
    unless Keyword.get(opts, :silent, false), do: IO.write("\a")
    
    case detect_terminal() do
      :iterm2 ->
        IO.write("\e]9;#{title}: #{body}\a")
        IO.write("\e]1337;RequestAttention=once\a")
      :kitty ->
        IO.write("\e]99;i=1:d=0:p=title;#{title}\e\\")
        IO.write("\e]99;i=1:d=1:p=body;#{body}\e\\")
      _ ->
        :ok  # Bell already sent above
    end
  end
  
  @doc "System notification only"
  def system_notify(title, body, opts \\ []) do
    case :os.type() do
      {:unix, :darwin} -> macos_notify(title, body, opts)
      {:unix, _}       -> linux_notify(title, body, opts)
      {:win32, _}      -> windows_notify(title, body, opts)
      _                -> {:error, :unsupported_os}
    end
  end
  
  # ============ PLATFORM IMPLEMENTATIONS ============
  
  defp macos_notify(title, body, opts) do
    # Prefer terminal-notifier if available (richer features)
    case System.find_executable("terminal-notifier") do
      nil -> osascript_notify(title, body, opts)
      path -> terminal_notifier_notify(path, title, body, opts)
    end
  end
  
  defp osascript_notify(title, body, opts) do
    sound = Keyword.get(opts, :sound)
    script = ~s(display notification "#{escape_applescript(body)}" with title "#{escape_applescript(title)}")
    script = if sound, do: script <> ~s( sound name "#{sound}"), else: script
    
    safe_cmd("osascript", ["-e", script])
  end
  
  defp terminal_notifier_notify(path, title, body, opts) do
    args = ["-message", body, "-title", title]
    args = args ++ if opts[:sound], do: ["-sound", opts[:sound]], else: []
    args = args ++ if opts[:open], do: ["-open", opts[:open]], else: []
    
    safe_cmd(path, args)
  end
  
  defp linux_notify(title, body, opts) do
    case System.find_executable("notify-send") do
      nil -> {:error, :notify_send_not_found}
      path ->
        args = [title, body]
        args = if opts[:urgency], do: ["--urgency=#{opts[:urgency]}" | args], else: args
        args = if opts[:icon], do: ["--icon=#{opts[:icon]}" | args], else: args
        safe_cmd(path, args)
    end
  end
  
  defp windows_notify(title, body, _opts) do
    script = """
    [Windows.UI.Notifications.ToastNotificationManager, Windows.UI.Notifications, ContentType = WindowsRuntime] | Out-Null
    [Windows.Data.Xml.Dom.XmlDocument, Windows.Data.Xml.Dom.XmlDocument, ContentType = WindowsRuntime] | Out-Null
    $xml = '<toast><visual><binding template="ToastGeneric"><text>#{escape_powershell(title)}</text><text>#{escape_powershell(body)}</text></binding></visual></toast>'
    $doc = [Windows.Data.Xml.Dom.XmlDocument]::New()
    $doc.LoadXml($xml)
    [Windows.UI.Notifications.ToastNotificationManager]::CreateToastNotifier('PowerShell').Show([Windows.UI.Notifications.ToastNotification]::new($doc))
    """
    safe_cmd("powershell", ["-NoProfile", "-ExecutionPolicy", "Bypass", "-Command", script])
  end
  
  # ============ HELPERS ============
  
  defp detect_terminal do
    cond do
      System.get_env("ITERM_SESSION_ID") -> :iterm2
      System.get_env("KITTY_WINDOW_ID")  -> :kitty
      System.get_env("WT_SESSION")       -> :windows_terminal
      System.get_env("TMUX")             -> :tmux
      true                               -> :unknown
    end
  end
  
  defp safe_cmd(cmd, args) do
    try do
      case System.cmd(cmd, args, stderr_to_stdout: true) do
        {_, 0} = result -> {:ok, result}
        {output, code}  -> {:error, {:exit_code, code, output}}
      end
    rescue
      e in ErlangError ->
        case e.original do
          :enoent -> {:error, :command_not_found}
          :eacces -> {:error, :permission_denied}
          other   -> {:error, other}
        end
    end
  end
  
  defp escape_applescript(str), do: String.replace(str, "\"", "\\\"")
  defp escape_powershell(str), do: String.replace(str, "'", "''")
end
```

## Integrating with a terminal-based coding assistant

For an LLM-powered coding assistant, notifications serve two purposes: alerting users when long-running tasks complete, and providing feedback without interrupting the terminal interface. Here's a pattern that integrates well:

```elixir
defmodule Assistant.TaskRunner do
  @doc "Run a task and notify on completion"
  def run_with_notification(task_fn, task_name \\ "Task") do
    start_time = System.monotonic_time(:millisecond)
    
    result = task_fn.()
    
    elapsed = System.monotonic_time(:millisecond) - start_time
    
    # Only notify for tasks taking >5 seconds (avoid notification spam)
    if elapsed > 5_000 do
      status = if match?({:ok, _}, result), do: "completed", else: "failed"
      Notifier.notify(
        "#{task_name} #{status}",
        "Finished in #{format_duration(elapsed)}",
        sound: if(status == "failed", do: "Basso", else: "Glass")
      )
    end
    
    result
  end
  
  defp format_duration(ms) when ms < 1000, do: "#{ms}ms"
  defp format_duration(ms) when ms < 60_000, do: "#{Float.round(ms / 1000, 1)}s"
  defp format_duration(ms), do: "#{div(ms, 60_000)}m #{rem(div(ms, 1000), 60)}s"
end
```

## Trade-offs between approaches

**Shelling out via System.cmd** is the recommended approach for Elixir desktop notifications. The trade-offs are:

- **Native Elixir/NIFs**: No libraries exist. Building NIFs for notifications is complex because macOS's `UNUserNotificationCenter` requires an app bundle context, and the BEAM VM lacks a bundle identifier.

- **D-Bus libraries for Linux**: Erlang libraries like `erlang-dbus` or `dbux` exist, but add significant complexity compared to shelling out to `notify-send`. Only worthwhile if you need bidirectional notification callbacks.

- **Dependency on external tools**: `osascript` and `powershell` are pre-installed on their platforms. Linux requires `libnotify-bin` which is standard on desktop distributions. Terminal-notifier and BurntToast are optional enhancements.

- **Performance**: System.cmd spawns an OS process, adding ~10-50ms overhead. For infrequent notifications (task completion), this is negligible. For high-frequency use, consider `Task.start/1` for fire-and-forget execution.

## Conclusion

The most robust notification strategy for an Elixir terminal application layers **universal terminal bell** as the baseline, **terminal-specific escape sequences** for enhanced alerts in iTerm2/Kitty, and **platform-native system notifications** via osascript/notify-send/PowerShell. This approach requires zero Elixir dependencies, gracefully degrades when tools are missing, and provides a consistent API across platforms. The complete `Notifier` module above handles all edge cases including command-not-found errors, proper string escaping, and terminal detection—ready to integrate into a coding assistant or any long-running Elixir application.
