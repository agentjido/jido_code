# JidoCode Extensibility System Design

**A Phoenix channel-integrated plugin architecture mapping ClaudeCode patterns to Jido primitives**

JidoCode can leverage Jido's powerful agentic primitives—Actions, Signals, Agents, and Skills—to create an extensibility system that mirrors ClaudeCode's architecture while adding real-time Phoenix channel integration for state broadcasting. This design enables markdown-based definitions compatible with ClaudeCode, native Elixir module hooks, and seamless pub/sub messaging throughout the agent lifecycle.

## Jido primitives map naturally to extensibility concepts

The Jido framework provides ideal building blocks for a plugin system. **Actions** serve as schema-validated, discrete units of work—perfect for slash commands and tool implementations. **Signals** (CloudEvents-compliant messages) provide the pub/sub backbone for hooks and Phoenix channel integration. **Agents** are stateful GenServer entities that can represent sub-agents with persistent context. **Skills** compose multiple actions with routing logic, mapping directly to ClaudeCode's skill concept.

| ClaudeCode Component | Jido Primitive | Implementation Pattern |
|---------------------|----------------|------------------------|
| Slash Commands | `Jido.Action` | Actions with markdown-defined schemas |
| Sub-agents | `Jido.Agent` + `Jido.Agent.Server` | Dedicated agent processes with custom prompts |
| Skills | `Jido.Skill` | Bundles actions + signal routing |
| Hooks | `Jido.Signal.Bus` + dispatch adapters | Signal subscriptions triggering handlers |
| Plugins | Supervision tree + runtime registration | OTP-supervised plugin containers |

## Directory structure follows ClaudeCode conventions

The extensibility system uses a two-tier configuration approach with global and local settings that merge at runtime, with local settings taking precedence.

```
~/.jido_code/                          # Global configuration
├── settings.json                      # Global settings + hooks
├── JIDO.md                           # Global agent memory/instructions
├── commands/                          # Personal slash commands
│   └── *.md
├── agents/                            # Personal sub-agent definitions
│   └── *.md
├── skills/                            # Personal skills
│   └── skill-name/
│       ├── SKILL.md
│       └── scripts/
├── plugins/                           # Installed plugins
│   └── plugin-name/
│       └── .jido-plugin/
│           └── plugin.json
└── logs/

.jido_code/                            # Project-level configuration
├── settings.json                      # Project settings (overrides global)
├── JIDO.md                           # Project memory/instructions
├── commands/
│   └── *.md
├── agents/
│   └── *.md
├── skills/
│   └── skill-name/
│       └── SKILL.md
├── hooks/                             # Native Elixir hook modules
│   └── *.ex
└── plugins/
```

## JSON configuration schema with Phoenix channel directives

The settings.json schema extends ClaudeCode's format with Phoenix channel configuration and native Elixir hook support:

```json
{
  "$schema": "https://jidocode.dev/schemas/settings.json",
  "version": "1.0.0",
  
  "channels": {
    "default": {
      "socket": "ws://localhost:4000/socket",
      "topic": "jido:agent",
      "auth": {
        "type": "token",
        "token_env": "JIDO_CHANNEL_TOKEN"
      }
    },
    "ui_state": {
      "topic": "jido:ui",
      "broadcast_events": ["state_change", "progress", "error"]
    }
  },
  
  "permissions": {
    "allow": ["Bash(git:*)", "Read", "Write", "Edit"],
    "deny": ["Bash(rm -rf:*)"],
    "ask": ["Bash(npm:*)"]
  },
  
  "hooks": {
    "PreToolUse": [
      {
        "matcher": "Edit",
        "hooks": [
          {
            "type": "command",
            "command": "echo 'Editing file' >> ~/.jido_code/logs/audit.log",
            "timeout": 5000
          },
          {
            "type": "channel",
            "channel": "ui_state",
            "event": "tool_starting",
            "payload_template": "{\"tool\": \"{{tool_name}}\", \"timestamp\": \"{{timestamp}}\"}"
          }
        ]
      },
      {
        "matcher": "*",
        "hooks": [
          {
            "type": "elixir",
            "module": "MyApp.Hooks.AuditLogger",
            "function": "log_tool_use"
          }
        ]
      }
    ],
    "PostToolUse": [
      {
        "matcher": "*",
        "hooks": [
          {
            "type": "signal",
            "signal_type": "jido.tool.completed",
            "bus": ":jido_code_bus"
          }
        ]
      }
    ],
    "AgentStateChange": [
      {
        "matcher": "*",
        "hooks": [
          {
            "type": "channel",
            "channel": "ui_state",
            "event": "agent_state",
            "payload_template": "{\"agent_id\": \"{{agent_id}}\", \"state\": {{state_json}}}"
          }
        ]
      }
    ]
  },
  
  "agents": {
    "default_model": "claude-sonnet-4-20250514",
    "max_concurrent": 5
  },
  
  "plugins": {
    "enabled": ["git-tools", "code-analyzer"],
    "disabled": [],
    "marketplaces": {
      "community": {
        "source": "github",
        "repo": "jidocode/plugin-marketplace"
      }
    }
  }
}
```

### Hook type specifications

| Type | Fields | Description |
|------|--------|-------------|
| `command` | `command`, `timeout`, `env` | Shell command execution |
| `elixir` | `module`, `function`, `args` | Native Elixir callback |
| `channel` | `channel`, `event`, `payload_template` | Phoenix channel broadcast |
| `signal` | `signal_type`, `bus`, `data_template` | Jido Signal emission |
| `prompt` | `prompt`, `model` | LLM evaluation |

## Markdown format for sub-agents with channel directives

Sub-agents use YAML frontmatter compatible with ClaudeCode, extended with Jido-specific options:

```yaml
---
name: code-reviewer
description: Expert code review specialist. Analyzes code quality, security vulnerabilities, and maintainability issues.
model: sonnet
tools: Read, Grep, Glob, Bash(git diff:*)

# Jido-specific extensions
jido:
  agent_module: JidoCode.Agents.CodeReviewer    # Optional: custom Elixir module
  schema:
    review_depth: 
      type: enum
      values: [quick, standard, thorough]
      default: standard
    focus_areas:
      type: list
      items: string
      default: [security, performance]
  
  channels:
    broadcast_to: ui_state
    events:
      on_start: review_started
      on_finding: finding_detected
      on_complete: review_completed
    
  signals:
    emit:
      - type: "code.review.finding"
        on: finding
      - type: "code.review.complete"
        on: complete
    subscribe:
      - pattern: "code.changed.*"
        action: trigger_review
---

You are an expert code reviewer specializing in Elixir and functional programming patterns.

## Review Process
1. Read the target files using available tools
2. Analyze for code quality issues
3. Check security vulnerabilities
4. Evaluate performance implications
5. Suggest improvements with code examples

## Channel Broadcasting
When you discover findings, emit them for real-time UI updates:
@channel(finding_detected) { "severity": "{{severity}}", "file": "{{file}}", "line": {{line}}, "message": "{{message}}" }

## Output Format
Structure findings as:
- **Critical**: Security vulnerabilities, data exposure risks
- **Warning**: Performance issues, code smells
- **Info**: Style suggestions, minor improvements
```

### Channel directive syntax within markdown

The `@channel()` directive enables agents to broadcast messages directly from their prompts:

```markdown
@channel(event_name) { JSON payload with {{variable}} interpolation }
@channel(ui_state:progress) { "step": {{current_step}}, "total": {{total_steps}} }
```

This compiles to Jido Signal emissions that dispatch to configured Phoenix channels.

## Skill definitions mirror ClaudeCode with signal routing

```yaml
---
name: pdf-processor
description: Extract text, tables, and forms from PDF documents. Use when working with PDF files or document analysis tasks.
version: 1.2.0
allowed-tools: Read, Write, Bash(python:*)

jido:
  skill_module: JidoCode.Skills.PdfProcessor
  actions:
    - JidoCode.Actions.ExtractPdfText
    - JidoCode.Actions.ExtractPdfTables
    - JidoCode.Actions.FillPdfForm
  
  channels:
    broadcast_to: ui_state
    progress_events: true
    
  router:
    "pdf.extract.text": ExtractPdfText
    "pdf.extract.tables": ExtractPdfTables
    "pdf.form.fill": FillPdfForm
---

# PDF Processing Skill

## Quick Start

Extract text from a PDF:
```python
import pdfplumber
with pdfplumber.open("document.pdf") as pdf:
    for page in pdf.pages:
        text = page.extract_text()
        print(text)
```

## Progress Reporting
@channel(progress) { "operation": "extracting", "page": {{current_page}}, "total": {{total_pages}} }

## Available Operations
- **Text Extraction**: Full-text extraction with layout preservation
- **Table Extraction**: Structured table data to CSV/JSON
- **Form Filling**: Populate PDF forms programmatically

See [TABLES.md](TABLES.md) for advanced table extraction options.
```

## Plugin manifest bundles all extensibility components

```json
{
  "$schema": "https://jidocode.dev/schemas/plugin.json",
  "name": "code-quality",
  "version": "2.1.0",
  "description": "Comprehensive code quality tools including review, linting, and security analysis",
  "author": {
    "name": "JidoCode Community",
    "email": "plugins@jidocode.dev"
  },
  "license": "MIT",
  "repository": "https://github.com/jidocode/plugin-code-quality",
  "keywords": ["code-review", "linting", "security"],
  
  "elixir": {
    "application": "JidoCodeQuality",
    "mix_deps": [
      {:credo, "~> 1.7"},
      {:sobelow, "~> 0.13"}
    ]
  },
  
  "commands": "./commands",
  "agents": ["./agents"],
  "skills": "./skills",
  "hooks": "./config/hooks.json",
  
  "channels": {
    "required": ["ui_state"],
    "optional": ["notifications"]
  },
  
  "signals": {
    "emits": [
      "code.quality.issue",
      "code.review.complete",
      "security.vulnerability"
    ],
    "subscribes": [
      "file.saved",
      "git.commit"
    ]
  },
  
  "mcp_servers": {
    "credo-server": {
      "command": "elixir",
      "args": ["${JIDO_PLUGIN_ROOT}/servers/credo_server.exs"],
      "env": {
        "MIX_ENV": "prod"
      }
    }
  }
}
```

## Elixir code architecture using Jido patterns

### Core plugin registry and loader

```elixir
defmodule JidoCode.Extensibility.PluginRegistry do
  @moduledoc """
  Central registry for all loaded plugins, commands, agents, skills, and hooks.
  Uses Jido's Signal bus for plugin lifecycle events.
  """
  use GenServer
  
  alias Jido.Signal
  alias Jido.Signal.Bus
  
  defstruct plugins: %{},
            commands: %{},
            agents: %{},
            skills: %{},
            hooks: %{},
            channels: %{}
  
  def start_link(opts) do
    GenServer.start_link(__MODULE__, opts, name: __MODULE__)
  end
  
  def init(opts) do
    # Subscribe to plugin lifecycle signals
    Bus.subscribe(:jido_code_bus, "plugin.**", dispatch: {:pid, target: self()})
    
    state = %__MODULE__{
      channels: load_channel_config(opts[:settings_path])
    }
    
    # Load global and local plugins
    {:ok, load_all_plugins(state, opts)}
  end
  
  def register_plugin(plugin_manifest) do
    GenServer.call(__MODULE__, {:register_plugin, plugin_manifest})
  end
  
  def get_command(name), do: GenServer.call(__MODULE__, {:get_command, name})
  def get_agent(name), do: GenServer.call(__MODULE__, {:get_agent, name})
  def get_skill(name), do: GenServer.call(__MODULE__, {:get_skill, name})
  
  def handle_call({:register_plugin, manifest}, _from, state) do
    plugin = load_plugin_from_manifest(manifest)
    
    # Emit plugin loaded signal
    {:ok, signal} = Signal.new("plugin.loaded", %{
      plugin_name: manifest.name,
      version: manifest.version,
      capabilities: extract_capabilities(plugin)
    })
    Bus.publish(:jido_code_bus, [signal])
    
    new_state = %{state |
      plugins: Map.put(state.plugins, manifest.name, plugin),
      commands: Map.merge(state.commands, plugin.commands),
      agents: Map.merge(state.agents, plugin.agents),
      skills: Map.merge(state.skills, plugin.skills),
      hooks: merge_hooks(state.hooks, plugin.hooks)
    }
    
    {:reply, {:ok, plugin}, new_state}
  end
end
```

### Action-based slash command implementation

```elixir
defmodule JidoCode.Extensibility.Command do
  @moduledoc """
  Defines slash commands as Jido Actions with markdown-parsed configuration.
  """
  
  defmacro __using__(opts) do
    quote do
      use Jido.Action,
        name: unquote(opts[:name]),
        description: unquote(opts[:description]),
        schema: unquote(opts[:schema] || [])
      
      @command_config unquote(opts)
      
      def __command_config__, do: @command_config
    end
  end
  
  @doc """
  Parses a markdown command file into a Jido Action module at runtime.
  """
  def from_markdown(path) do
    {:ok, content} = File.read(path)
    {frontmatter, body} = parse_frontmatter(content)
    
    schema = build_schema_from_frontmatter(frontmatter)
    
    module_name = module_name_from_path(path)
    
    Module.create(module_name, quote do
      use Jido.Action,
        name: unquote(frontmatter["name"] || Path.basename(path, ".md")),
        description: unquote(frontmatter["description"]),
        schema: unquote(schema)
      
      @allowed_tools unquote(parse_tools(frontmatter["allowed-tools"]))
      @model_override unquote(frontmatter["model"])
      @prompt_body unquote(body)
      @channel_config unquote(frontmatter["jido"]["channels"])
      
      @impl true
      def run(params, context) do
        prompt = interpolate_prompt(@prompt_body, params)
        
        # Broadcast command start to configured channel
        maybe_broadcast_channel(@channel_config, "command_started", %{
          command: __MODULE__,
          params: params
        })
        
        result = execute_with_tools(prompt, @allowed_tools, context)
        
        maybe_broadcast_channel(@channel_config, "command_completed", %{
          command: __MODULE__,
          result: result
        })
        
        result
      end
    end, Macro.Env.location(__ENV__))
    
    {:ok, module_name}
  end
end
```

### Signal-based hook system with channel dispatch

```elixir
defmodule JidoCode.Extensibility.HookRunner do
  @moduledoc """
  Executes hooks based on lifecycle events, supporting shell commands,
  Elixir modules, Phoenix channels, and Jido signals.
  """
  
  alias Jido.Signal
  alias Jido.Signal.Bus
  alias Jido.Signal.Dispatch
  
  @lifecycle_events [
    :pre_tool_use,
    :post_tool_use,
    :permission_request,
    :agent_state_change,
    :session_start,
    :session_stop,
    :subagent_start,
    :subagent_stop,
    :user_prompt_submit,
    :error
  ]
  
  def init(hook_config, channel_config) do
    # Subscribe to all lifecycle signals
    Enum.each(@lifecycle_events, fn event ->
      pattern = "jido.lifecycle.#{event}"
      Bus.subscribe(:jido_code_bus, pattern, dispatch: {:pid, target: self()})
    end)
    
    %{
      hooks: normalize_hooks(hook_config),
      channels: channel_config,
      channel_connections: connect_channels(channel_config)
    }
  end
  
  def handle_info({:signal, signal}, state) do
    event_type = signal_to_event(signal.type)
    matching_hooks = find_matching_hooks(state.hooks, event_type, signal.data)
    
    # Run all matching hooks in parallel
    tasks = Enum.map(matching_hooks, fn hook ->
      Task.async(fn -> execute_hook(hook, signal, state) end)
    end)
    
    results = Task.await_many(tasks, :timer.seconds(60))
    
    # Process hook decisions (approve/deny/ask)
    decision = aggregate_decisions(results)
    
    {:noreply, state, decision}
  end
  
  defp execute_hook(%{type: "command"} = hook, signal, _state) do
    env = build_env_vars(signal)
    {output, exit_code} = System.cmd("sh", ["-c", hook.command], env: env)
    parse_hook_output(output, exit_code)
  end
  
  defp execute_hook(%{type: "elixir"} = hook, signal, _state) do
    module = String.to_existing_atom("Elixir.#{hook.module}")
    function = String.to_atom(hook.function)
    args = [signal.data | hook.args || []]
    
    apply(module, function, args)
  end
  
  defp execute_hook(%{type: "channel"} = hook, signal, state) do
    channel_name = hook.channel
    event = hook.event
    payload = interpolate_template(hook.payload_template, signal.data)
    
    case Map.get(state.channel_connections, channel_name) do
      nil -> {:error, :channel_not_connected}
      channel ->
        Phoenix.Channel.push(channel, event, payload)
        {:ok, :broadcast_sent}
    end
  end
  
  defp execute_hook(%{type: "signal"} = hook, signal, _state) do
    {:ok, new_signal} = Signal.new(
      hook.signal_type,
      Map.merge(signal.data, %{source_signal: signal.id}),
      source: "/hooks/#{hook.id}"
    )
    
    Bus.publish(String.to_atom(hook.bus), [new_signal])
    {:ok, :signal_emitted}
  end
end
```

### Sub-agent implementation as Jido Agent

```elixir
defmodule JidoCode.Extensibility.SubAgent do
  @moduledoc """
  Sub-agents implemented as Jido Agents with Phoenix channel state broadcasting.
  """
  
  defmacro __using__(opts) do
    quote do
      use Jido.Agent,
        name: unquote(opts[:name]),
        description: unquote(opts[:description]),
        actions: unquote(opts[:actions] || []),
        schema: unquote(opts[:schema] || [])
      
      alias Jido.Signal
      alias Jido.Signal.Bus
      
      @channel_config unquote(opts[:channels])
      @signal_config unquote(opts[:signals])
      @system_prompt unquote(opts[:system_prompt])
      
      def start_link(opts) do
        JidoCode.Extensibility.SubAgent.Server.start_link(__MODULE__, opts)
      end
      
      def broadcast_state_change(agent_pid, new_state) do
        GenServer.cast(agent_pid, {:broadcast_state, new_state})
      end
    end
  end
  
  defmodule Server do
    use Jido.Agent.Server
    
    @impl true
    def init(agent_module, opts) do
      # Connect to Phoenix channel for state broadcasting
      channel = connect_to_channel(agent_module.__channel_config__())
      
      # Subscribe to configured signal patterns
      setup_signal_subscriptions(agent_module.__signal_config__())
      
      initial_state = %{
        id: opts[:id] || Jido.ID.generate(),
        agent_module: agent_module,
        system_prompt: agent_module.__system_prompt__(),
        channel: channel,
        status: :idle,
        context: %{}
      }
      
      # Broadcast agent start
      broadcast_event(channel, "agent_started", %{
        agent_id: initial_state.id,
        agent_type: agent_module.__name__()
      })
      
      {:ok, initial_state}
    end
    
    @impl true
    def handle_instruction({action, params}, state) do
      # Broadcast instruction start
      broadcast_event(state.channel, "instruction_started", %{
        agent_id: state.id,
        action: action,
        params: sanitize_params(params)
      })
      
      new_state = %{state | status: :executing}
      broadcast_state(state.channel, state.id, new_state)
      
      case apply_instruction(action, params, state) do
        {:ok, result_state} ->
          broadcast_event(state.channel, "instruction_completed", %{
            agent_id: state.id,
            action: action,
            success: true
          })
          {:ok, %{result_state | status: :idle}}
          
        {:error, reason} ->
          broadcast_event(state.channel, "instruction_failed", %{
            agent_id: state.id,
            action: action,
            error: inspect(reason)
          })
          {:error, reason, %{state | status: :error}}
      end
    end
    
    defp broadcast_state(channel, agent_id, state) do
      Phoenix.Channel.push(channel, "agent_state", %{
        agent_id: agent_id,
        status: state.status,
        context: safe_serialize(state.context),
        timestamp: DateTime.utc_now()
      })
    end
  end
  
  @doc """
  Parses a markdown sub-agent definition into a module.
  """
  def from_markdown(path) do
    {:ok, content} = File.read(path)
    {frontmatter, body} = parse_frontmatter(content)
    
    jido_config = frontmatter["jido"] || %{}
    
    module_name = module_name_from_path(path)
    
    Module.create(module_name, quote do
      use JidoCode.Extensibility.SubAgent,
        name: unquote(frontmatter["name"]),
        description: unquote(frontmatter["description"]),
        schema: unquote(build_schema(jido_config["schema"])),
        channels: unquote(jido_config["channels"]),
        signals: unquote(jido_config["signals"]),
        system_prompt: unquote(body)
      
      @tools unquote(parse_tools(frontmatter["tools"]))
      @model unquote(frontmatter["model"] || "sonnet")
    end, Macro.Env.location(__ENV__))
    
    {:ok, module_name}
  end
end
```

### Phoenix channel integration module

```elixir
defmodule JidoCode.Channels.AgentStateChannel do
  @moduledoc """
  Phoenix channel for real-time agent state broadcasting.
  Integrates with Jido Signal bus for event distribution.
  """
  
  use Phoenix.Channel
  
  alias Jido.Signal.Bus
  
  def join("jido:agent:" <> agent_id, _params, socket) do
    # Subscribe to agent-specific signals
    Bus.subscribe(:jido_code_bus, "agent.#{agent_id}.*", 
      dispatch: {:pid, target: self()})
    
    {:ok, assign(socket, :agent_id, agent_id)}
  end
  
  def join("jido:ui", _params, socket) do
    # Subscribe to all UI-relevant signals
    Bus.subscribe(:jido_code_bus, "ui.**", 
      dispatch: {:pid, target: self()})
    
    {:ok, socket}
  end
  
  # Handle signals from Jido bus and broadcast to channel
  def handle_info({:signal, signal}, socket) do
    event_name = signal_type_to_event(signal.type)
    push(socket, event_name, signal.data)
    {:noreply, socket}
  end
  
  # Handle incoming channel events and convert to signals
  def handle_in("user_input", %{"content" => content}, socket) do
    {:ok, signal} = Jido.Signal.new("user.input", %{
      content: content,
      agent_id: socket.assigns[:agent_id],
      channel: socket.topic
    })
    
    Bus.publish(:jido_code_bus, [signal])
    
    {:noreply, socket}
  end
  
  defp signal_type_to_event(type) do
    type
    |> String.replace(".", "_")
    |> String.replace("jido_", "")
  end
end
```

### Skill implementation with action bundling

```elixir
defmodule JidoCode.Extensibility.Skill do
  @moduledoc """
  Skills as Jido.Skill implementations with channel integration.
  """
  
  defmacro __using__(opts) do
    quote do
      use Jido.Skill, name: unquote(opts[:name])
      
      @description unquote(opts[:description])
      @version unquote(opts[:version])
      @actions unquote(opts[:actions] || [])
      @channel_config unquote(opts[:channels])
      @router_config unquote(opts[:router])
      
      def mount(agent, opts \\ []) do
        # Register all skill actions with the agent
        Enum.each(@actions, fn action ->
          Jido.Agent.register_action(agent, action)
        end)
        
        # Setup channel broadcasting if configured
        if @channel_config do
          setup_channel_broadcasting(agent, @channel_config)
        end
        
        {:ok, agent}
      end
      
      def router(opts \\ []) do
        Enum.map(@router_config, fn {pattern, action} ->
          {pattern, %Jido.Instruction{action: action}}
        end)
      end
      
      def handle_signal(signal, skill_opts) do
        case find_matching_route(signal.type, @router_config) do
          nil -> {:skip, signal}
          action -> {:ok, %Jido.Instruction{action: action, params: signal.data}}
        end
      end
    end
  end
  
  def from_markdown(path) do
    skill_dir = Path.dirname(path)
    {:ok, content} = File.read(path)
    {frontmatter, body} = parse_frontmatter(content)
    
    jido_config = frontmatter["jido"] || %{}
    
    module_name = module_name_from_path(path)
    
    # Load and compile action modules if specified
    actions = compile_skill_actions(jido_config["actions"], skill_dir)
    
    Module.create(module_name, quote do
      use JidoCode.Extensibility.Skill,
        name: unquote(frontmatter["name"]),
        description: unquote(frontmatter["description"]),
        version: unquote(frontmatter["version"]),
        actions: unquote(actions),
        channels: unquote(jido_config["channels"]),
        router: unquote(jido_config["router"])
      
      @allowed_tools unquote(parse_tools(frontmatter["allowed-tools"]))
      @skill_body unquote(body)
      
      def skill_documentation, do: @skill_body
    end, Macro.Env.location(__ENV__))
    
    {:ok, module_name}
  end
end
```

## TermUI integration for state representation

The extensibility system integrates with TermUI's Elm Architecture for real-time state display:

```elixir
defmodule JidoCode.UI.ExtensibilityPanel do
  @moduledoc """
  TermUI component for displaying plugin/agent state.
  Receives updates via Phoenix channel subscriptions.
  """
  
  alias TermUI.Renderer.Style
  
  defstruct agents: %{},
            active_hooks: [],
            loaded_plugins: [],
            channel_status: :disconnected
  
  def init(_opts) do
    %__MODULE__{}
  end
  
  def event_to_msg(%{type: :channel_event, event: "agent_state"} = event, _state) do
    {:msg, {:agent_state_update, event.payload}}
  end
  
  def event_to_msg(%{type: :channel_event, event: "hook_triggered"} = event, _state) do
    {:msg, {:hook_triggered, event.payload}}
  end
  
  def event_to_msg(_, _state), do: :ignore
  
  def update({:agent_state_update, payload}, state) do
    agent_id = payload["agent_id"]
    updated_agents = Map.put(state.agents, agent_id, %{
      status: payload["status"],
      last_update: payload["timestamp"],
      context: payload["context"]
    })
    
    {%{state | agents: updated_agents}, []}
  end
  
  def update({:hook_triggered, payload}, state) do
    hook_entry = %{
      name: payload["hook_name"],
      event: payload["event"],
      timestamp: DateTime.utc_now()
    }
    
    # Keep last 10 hooks
    hooks = [hook_entry | state.active_hooks] |> Enum.take(10)
    
    {%{state | active_hooks: hooks}, []}
  end
  
  def view(state) do
    import TermUI.Elements
    
    stack(:vertical, [
      panel("Agent Status", agent_status_view(state.agents)),
      panel("Recent Hooks", hooks_view(state.active_hooks)),
      panel("Loaded Plugins", plugins_view(state.loaded_plugins)),
      status_bar(state.channel_status)
    ])
  end
  
  defp agent_status_view(agents) do
    agents
    |> Enum.map(fn {id, agent} ->
      status_style = case agent.status do
        :idle -> Style.new(fg: :green)
        :executing -> Style.new(fg: :yellow, attrs: [:bold])
        :error -> Style.new(fg: :red)
      end
      
      row([
        text(truncate(id, 12), Style.new(fg: :cyan)),
        text(to_string(agent.status), status_style),
        text(format_time(agent.last_update), Style.new(fg: :white))
      ])
    end)
    |> stack(:vertical)
  end
end
```

## Application supervision tree

```elixir
defmodule JidoCode.Application do
  use Application
  
  def start(_type, _args) do
    children = [
      # Core Jido Signal bus for extensibility events
      {Jido.Signal.Bus, name: :jido_code_bus, middleware: [
        {Jido.Signal.Bus.Middleware.Logger, level: :debug}
      ]},
      
      # Plugin registry - loads all plugins at startup
      {JidoCode.Extensibility.PluginRegistry, [
        global_path: Path.expand("~/.jido_code"),
        local_path: ".jido_code"
      ]},
      
      # Hook runner - handles all lifecycle hooks
      {JidoCode.Extensibility.HookRunner, [
        settings_path: ".jido_code/settings.json"
      ]},
      
      # Phoenix endpoint for channel connections
      JidoCode.Endpoint,
      
      # TermUI application
      {TermUI.Application, app: JidoCode.UI.App},
      
      # Dynamic supervisor for sub-agents
      {DynamicSupervisor, name: JidoCode.AgentSupervisor, strategy: :one_for_one}
    ]
    
    opts = [strategy: :one_for_one, name: JidoCode.Supervisor]
    Supervisor.start_link(children, opts)
  end
end
```

## Summary of key integration points

The extensibility system creates a cohesive architecture where **ClaudeCode compatibility** is maintained through markdown-based definitions with YAML frontmatter, enabling potential reuse of existing ClaudeCode skills and agents. The `jido:` frontmatter extension adds Elixir-native capabilities without breaking compatibility.

**Phoenix channels** integrate at three levels: hook definitions can include `type: "channel"` entries that broadcast on lifecycle events; sub-agents and skills can specify `channels.broadcast_to` for automatic state synchronization; and the `@channel()` directive in markdown prompts enables agents to emit real-time updates during execution.

**Jido primitives** provide the foundation: Actions implement commands with schema validation, Signals flow through the bus connecting all components, Agents wrap sub-agent definitions with full GenServer lifecycle, and Skills compose actions with intelligent routing. The Signal bus acts as the central nervous system, with Phoenix channel dispatch adapters bridging to the TermUI for real-time visualization.

This design enables **progressive adoption**—teams can start with simple markdown commands and gradually add channel broadcasting, native Elixir hooks, and full plugin bundles as needs grow.
