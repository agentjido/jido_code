# Unified code validation pipeline for JidoCode

The most effective architecture for JidoCode's validation pipeline is a **Skill-based middleware layer** that wraps LLM code generation with pre-validation context injection and post-validation feedback loops. This design leverages Jido's existing primitives—Actions, Skills, and Workflows—to create a seamless integration that supports intelligent retry logic with violation scoring across three unified domains: Credo styling, anti-patterns, and security vulnerabilities.

The pipeline operates on a simple principle: **prevent violations before generation where possible, detect what slips through after generation, and iteratively improve until an acceptable threshold is reached**. A unified severity model allows consistent decision-making about which violations block acceptance versus trigger warnings.

## Pipeline architecture: pre-generation through validation and retry

The complete validation flow integrates with Jido's existing DAG-based workflow orchestration through a dedicated `ValidationSkill` that intercepts code generation requests.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    JIDOCODE VALIDATION PIPELINE                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │ STAGE 1: PRE-GENERATION                                              │   │
│  │                                                                      │   │
│  │  [Request Analysis] → [Constraint Selection] → [Prompt Enrichment]   │   │
│  │         │                     │                        │             │   │
│  │    Parse intent          SPARQL query for         Inject rules,      │   │
│  │    & context             applicable rules         examples, guards   │   │
│  └──────────────────────────────────────────────────────────────────────┘   │
│                                    ↓                                        │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │ STAGE 2: CODE GENERATION                                             │   │
│  │                                                                      │   │
│  │  [LLM Agent] ← Enriched prompt with constraints & negative examples  │   │
│  │       ↓                                                              │   │
│  │  Generated Elixir code                                               │   │
│  └──────────────────────────────────────────────────────────────────────┘   │
│                                    ↓                                        │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │ STAGE 3: POST-GENERATION VALIDATION (Parallel Execution)            │   │
│  │                                                                      │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐                   │   │
│  │  │   Credo     │  │ Anti-Pattern│  │  Security   │                   │   │
│  │  │ Validator   │  │  Detector   │  │  Scanner    │                   │   │
│  │  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘                   │   │
│  │         └────────────────┼────────────────┘                          │   │
│  │                          ↓                                           │   │
│  │              [Violation Aggregator & Scorer]                         │   │
│  └──────────────────────────────────────────────────────────────────────┘   │
│                                    ↓                                        │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │ STAGE 4: DECISION & RETRY LOGIC                                      │   │
│  │                                                                      │   │
│  │  Score < threshold  ────────→  Return best attempt                   │   │
│  │         │                                                            │   │
│  │  Score >= threshold AND attempts < max ───→ Retry with feedback      │   │
│  │         │                                                            │   │
│  │  Score >= threshold AND attempts >= max ──→ Return best attempt      │   │
│  │                                              with violation report   │   │
│  └──────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

**Pre-generation** queries the knowledge graph to identify applicable constraints based on the generation context (module type, OTP patterns detected, libraries used). These constraints are injected into the LLM prompt as explicit rules with examples of violations to avoid.

**Post-generation validation** runs all three validators in parallel using Elixir's Task.async_stream, collecting violations into a unified format. The aggregator scores violations using weighted severity, comparing against configurable thresholds.

**Retry logic** tracks all attempts, storing violations and scores. When maximum retries are exhausted or score falls below threshold, the pipeline returns the attempt with the lowest weighted violation score, even if imperfect.

## Unified ontology for cross-domain validation

The ontology extends the existing Elixir core ontology with a unified validation layer that enables querying across Credo, anti-patterns, and security domains through common superclasses.

```turtle
@prefix elx: <http://jidocode.dev/ontology/elixir#> .
@prefix val: <http://jidocode.dev/ontology/validation#> .
@prefix credo: <http://jidocode.dev/ontology/credo#> .
@prefix smell: <http://jidocode.dev/ontology/smells#> .
@prefix sec: <http://jidocode.dev/ontology/security#> .
@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

# ═══════════════════════════════════════════════════════════════════════════
# UNIFIED VALIDATION SUPERCLASSES
# ═══════════════════════════════════════════════════════════════════════════

val:ValidationRule a owl:Class ;
    rdfs:label "Validation Rule" ;
    rdfs:comment "Abstract superclass for all validation rules across domains" .

val:Violation a owl:Class ;
    rdfs:label "Violation" ;
    rdfs:comment "An instance of a rule being violated in generated code" .

val:Severity a owl:Class ;
    rdfs:label "Severity Level" ;
    rdfs:comment "Unified severity classification" .

# Unified severity levels with numeric weights
val:Critical a val:Severity ; val:weight 100 ; val:blocking true ;
    rdfs:comment "Must fix - blocks code acceptance" .
val:High a val:Severity ; val:weight 50 ; val:blocking true ;
    rdfs:comment "Should fix - strongly recommended before acceptance" .
val:Medium a val:Severity ; val:weight 20 ; val:blocking false ;
    rdfs:comment "Consider fixing - acceptable with justification" .
val:Low a val:Severity ; val:weight 5 ; val:blocking false ;
    rdfs:comment "Nice to fix - informational guidance" .
val:Info a val:Severity ; val:weight 1 ; val:blocking false ;
    rdfs:comment "Suggestion - stylistic preference" .

# Common properties
val:hasSeverity a owl:ObjectProperty ;
    rdfs:domain val:ValidationRule ;
    rdfs:range val:Severity .

val:affectsCodeElement a owl:ObjectProperty ;
    rdfs:domain val:Violation ;
    rdfs:range elx:CodeElement .

val:hasRemediation a owl:DatatypeProperty ;
    rdfs:domain val:ValidationRule ;
    rdfs:range xsd:string ;
    rdfs:comment "Guidance for fixing violations" .

val:hasNegativeExample a owl:DatatypeProperty ;
    rdfs:domain val:ValidationRule ;
    rdfs:range xsd:string ;
    rdfs:comment "Code example showing the violation pattern" .

val:hasPositiveExample a owl:DatatypeProperty ;
    rdfs:domain val:ValidationRule ;
    rdfs:range xsd:string ;
    rdfs:comment "Code example showing correct pattern" .

# ═══════════════════════════════════════════════════════════════════════════
# CREDO DOMAIN
# ═══════════════════════════════════════════════════════════════════════════

credo:CredoRule rdfs:subClassOf val:ValidationRule ;
    rdfs:label "Credo Rule" .

credo:ConsistencyRule rdfs:subClassOf credo:CredoRule ;
    val:defaultSeverity val:Low .
credo:DesignRule rdfs:subClassOf credo:CredoRule ;
    val:defaultSeverity val:Medium .
credo:ReadabilityRule rdfs:subClassOf credo:CredoRule ;
    val:defaultSeverity val:Low .
credo:RefactorRule rdfs:subClassOf credo:CredoRule ;
    val:defaultSeverity val:Medium .
credo:WarningRule rdfs:subClassOf credo:CredoRule ;
    val:defaultSeverity val:High .

# ═══════════════════════════════════════════════════════════════════════════
# ANTI-PATTERN / CODE SMELL DOMAIN
# ═══════════════════════════════════════════════════════════════════════════

smell:AntiPattern rdfs:subClassOf val:ValidationRule ;
    rdfs:label "Anti-Pattern" .

smell:DesignSmell rdfs:subClassOf smell:AntiPattern ;
    val:defaultSeverity val:Medium .
smell:LowLevelSmell rdfs:subClassOf smell:AntiPattern ;
    val:defaultSeverity val:Low .
smell:ProcessSmell rdfs:subClassOf smell:AntiPattern ;
    val:defaultSeverity val:High .
smell:MetaprogrammingSmell rdfs:subClassOf smell:AntiPattern ;
    val:defaultSeverity val:Medium .

# Specific anti-patterns from Elixir Code Smells catalog
smell:GenServerEnvy a smell:ProcessSmell ;
    val:hasSeverity val:High ;
    rdfs:comment "Using Task/Agent when GenServer is appropriate" ;
    val:hasNegativeExample "Task.async(fn -> maintain_state() end)" ;
    val:hasPositiveExample "GenServer with handle_call/cast for stateful operations" .

smell:UnsupervisedProcess a smell:ProcessSmell ;
    val:hasSeverity val:Critical ;
    rdfs:comment "Spawning processes outside supervision trees" ;
    val:hasNegativeExample "spawn(fn -> critical_work() end)" ;
    val:hasPositiveExample "DynamicSupervisor.start_child/2" .

smell:LargeMessages a smell:ProcessSmell ;
    val:hasSeverity val:Medium ;
    rdfs:comment "Sending large data structures between processes" .

smell:DynamicAtomCreation a smell:LowLevelSmell ;
    val:hasSeverity val:High ;
    rdfs:comment "Creating atoms at runtime from user input" ;
    val:hasNegativeExample "String.to_atom(user_input)" ;
    val:hasPositiveExample "String.to_existing_atom(user_input)" .

# ═══════════════════════════════════════════════════════════════════════════
# SECURITY DOMAIN
# ═══════════════════════════════════════════════════════════════════════════

sec:SecurityVulnerability rdfs:subClassOf val:ValidationRule ;
    rdfs:label "Security Vulnerability" .

sec:InjectionVulnerability rdfs:subClassOf sec:SecurityVulnerability ;
    val:defaultSeverity val:Critical .
sec:SQLInjection rdfs:subClassOf sec:InjectionVulnerability .
sec:CommandInjection rdfs:subClassOf sec:InjectionVulnerability .
sec:CodeInjection rdfs:subClassOf sec:InjectionVulnerability .

sec:XSSVulnerability rdfs:subClassOf sec:SecurityVulnerability ;
    val:defaultSeverity val:Critical .

sec:TraversalVulnerability rdfs:subClassOf sec:SecurityVulnerability ;
    val:defaultSeverity val:Critical ;
    val:hasNegativeExample "File.read!(user_provided_path)" ;
    val:hasPositiveExample "Path.expand(path) |> validate_within_allowed_directory()" .

sec:ConfigurationVulnerability rdfs:subClassOf sec:SecurityVulnerability ;
    val:defaultSeverity val:High .
sec:HardcodedSecret rdfs:subClassOf sec:ConfigurationVulnerability ;
    val:hasSeverity val:Critical .

sec:CryptographicWeakness rdfs:subClassOf sec:SecurityVulnerability ;
    val:defaultSeverity val:High .
sec:WeakHashAlgorithm rdfs:subClassOf sec:CryptographicWeakness ;
    val:hasNegativeExample ":crypto.hash(:md5, data)" ;
    val:hasPositiveExample ":crypto.hash(:sha256, data)" .

sec:ResourceExhaustion rdfs:subClassOf sec:SecurityVulnerability ;
    val:defaultSeverity val:Medium .
sec:AtomTableExhaustion rdfs:subClassOf sec:ResourceExhaustion ;
    val:hasSeverity val:High .
```

The ontology enables **unified querying** across domains through the common `val:ValidationRule` superclass while preserving domain-specific semantics. The **numeric severity weights** allow consistent scoring, and the **blocking** property determines whether violations prevent acceptance.

## SPARQL query patterns for each validation domain

These queries retrieve applicable rules and validate code representations against the knowledge graph.

### Cross-domain applicable rules query

```sparql
PREFIX val: <http://jidocode.dev/ontology/validation#>
PREFIX elx: <http://jidocode.dev/ontology/elixir#>

# Retrieve all validation rules applicable to a specific code context
SELECT ?rule ?domain ?severity ?weight ?blocking ?remediation ?negativeExample
WHERE {
  ?rule a/rdfs:subClassOf* val:ValidationRule .
  ?rule val:hasSeverity ?severity .
  ?severity val:weight ?weight .
  ?severity val:blocking ?blocking .
  
  OPTIONAL { ?rule val:hasRemediation ?remediation }
  OPTIONAL { ?rule val:hasNegativeExample ?negativeExample }
  
  # Determine domain for categorization
  BIND(
    IF(EXISTS { ?rule a/rdfs:subClassOf* credo:CredoRule }, "credo",
    IF(EXISTS { ?rule a/rdfs:subClassOf* smell:AntiPattern }, "smell",
    IF(EXISTS { ?rule a/rdfs:subClassOf* sec:SecurityVulnerability }, "security",
    "unknown"))) AS ?domain
  )
  
  # Filter by code element type if provided
  OPTIONAL {
    ?rule val:applicableTo ?elementType .
    FILTER(?elementType = ?targetElementType)
  }
}
ORDER BY DESC(?weight)
```

### Credo-specific pattern detection query

```sparql
PREFIX credo: <http://jidocode.dev/ontology/credo#>
PREFIX val: <http://jidocode.dev/ontology/validation#>
PREFIX elx: <http://jidocode.dev/ontology/elixir#>

# Find Credo violations in code representation
SELECT ?function ?ruleName ?severity ?message
WHERE {
  ?function a elx:Function .
  
  # Check for long parameter lists (Credo.Check.Refactor.LongQuoteBlocks equivalent)
  {
    ?function elx:hasArity ?arity .
    FILTER(?arity > 5)
    BIND(credo:TooManyParameters AS ?rule)
    BIND("Function has too many parameters" AS ?message)
  }
  UNION
  # Check for deeply nested structures
  {
    ?function elx:hasNestingDepth ?depth .
    FILTER(?depth > 3)
    BIND(credo:DeeplyNested AS ?rule)
    BIND("Deeply nested code structure" AS ?message)
  }
  UNION
  # Check for module naming consistency
  {
    ?function elx:inModule ?module .
    ?module elx:moduleName ?name .
    FILTER(!REGEX(?name, "^[A-Z][a-zA-Z0-9]*$"))
    BIND(credo:ModuleNaming AS ?rule)
    BIND("Module name doesn't follow conventions" AS ?message)
  }
  
  ?rule rdfs:label ?ruleName .
  ?rule val:hasSeverity/rdfs:label ?severity .
}
```

### Anti-pattern detection query

```sparql
PREFIX smell: <http://jidocode.dev/ontology/smells#>
PREFIX val: <http://jidocode.dev/ontology/validation#>
PREFIX elx: <http://jidocode.dev/ontology/elixir#>

# Detect process-related anti-patterns
SELECT ?codeElement ?antiPattern ?severity ?remediation
WHERE {
  # Unsupervised process detection
  {
    ?codeElement a elx:FunctionCall .
    ?codeElement elx:callsFunction ?func .
    FILTER(?func IN (elx:spawn, elx:spawn_link, elx:Task_async))
    
    # Check if within supervision context
    FILTER NOT EXISTS {
      ?codeElement elx:withinContext ?context .
      ?context a elx:SupervisorContext .
    }
    
    BIND(smell:UnsupervisedProcess AS ?antiPattern)
  }
  UNION
  # Dynamic atom creation
  {
    ?codeElement a elx:FunctionCall .
    ?codeElement elx:callsFunction elx:String_to_atom .
    ?codeElement elx:hasArgument ?arg .
    ?arg elx:sourceType elx:UserInput .
    
    BIND(smell:DynamicAtomCreation AS ?antiPattern)
  }
  UNION
  # GenServer envy - using Agent for complex state
  {
    ?codeElement a elx:ModuleDefinition .
    ?codeElement elx:usesModule elx:Agent .
    ?codeElement elx:hasStateComplexity ?complexity .
    FILTER(?complexity > 3)
    
    BIND(smell:GenServerEnvy AS ?antiPattern)
  }
  
  ?antiPattern val:hasSeverity ?sev .
  ?sev rdfs:label ?severity .
  OPTIONAL { ?antiPattern val:hasRemediation ?remediation }
}
```

### Security vulnerability detection query

```sparql
PREFIX sec: <http://jidocode.dev/ontology/security#>
PREFIX val: <http://jidocode.dev/ontology/validation#>
PREFIX elx: <http://jidocode.dev/ontology/elixir#>

# Comprehensive security vulnerability scan
SELECT ?location ?vulnerability ?severity ?weight ?evidence ?remediation
WHERE {
  # SQL Injection - raw query with user input
  {
    ?location a elx:FunctionCall .
    ?location elx:callsFunction ?sqlFunc .
    FILTER(?sqlFunc IN (elx:Ecto_query, elx:Repo_query))
    ?location elx:hasRawSQL true .
    ?location elx:interpolatesInput ?input .
    ?input elx:taintedBy elx:UserInput .
    
    BIND(sec:SQLInjection AS ?vulnerability)
    BIND("Raw SQL with interpolated user input" AS ?evidence)
  }
  UNION
  # Command injection
  {
    ?location a elx:FunctionCall .
    ?location elx:callsFunction ?cmdFunc .
    FILTER(?cmdFunc IN (elx:System_cmd, elx:Port_open, elx:os_cmd))
    ?location elx:hasArgument ?arg .
    ?arg elx:taintedBy elx:UserInput .
    
    BIND(sec:CommandInjection AS ?vulnerability)
    BIND("System command with user-controlled input" AS ?evidence)
  }
  UNION
  # Hardcoded secrets
  {
    ?location a elx:Assignment .
    ?location elx:variableName ?name .
    FILTER(REGEX(?name, "(password|secret|api_key|token)", "i"))
    ?location elx:assignsLiteral ?literal .
    FILTER(STRLEN(?literal) > 8)
    
    BIND(sec:HardcodedSecret AS ?vulnerability)
    BIND(CONCAT("Hardcoded value in variable: ", ?name) AS ?evidence)
  }
  UNION
  # Path traversal
  {
    ?location a elx:FunctionCall .
    ?location elx:callsFunction ?fileFunc .
    FILTER(?fileFunc IN (elx:File_read, elx:File_write, elx:File_open))
    ?location elx:hasArgument ?path .
    ?path elx:taintedBy elx:UserInput .
    FILTER NOT EXISTS {
      ?path elx:sanitizedBy elx:PathValidation .
    }
    
    BIND(sec:TraversalVulnerability AS ?vulnerability)
    BIND("File operation with unsanitized user path" AS ?evidence)
  }
  
  ?vulnerability val:hasSeverity ?sev .
  ?sev rdfs:label ?severity .
  ?sev val:weight ?weight .
  OPTIONAL { ?vulnerability val:hasRemediation ?remediation }
}
ORDER BY DESC(?weight)
```

## Pre-generation constraint injection strategies

The pre-generation phase enriches LLM prompts with contextually relevant constraints, examples, and guardrails before code generation begins.

### Strategy 1: Context-aware rule retrieval

The system analyzes the generation request to identify applicable rules and injects them as explicit constraints:

```elixir
defmodule JidoCode.PreGeneration.ConstraintInjector do
  @moduledoc """
  Enriches LLM prompts with validation constraints before generation.
  """
  
  alias JidoCode.KnowledgeGraph
  
  def inject_constraints(prompt, context) do
    # Analyze what type of code is being requested
    code_type = analyze_code_type(prompt)
    
    # Query knowledge graph for applicable rules
    {:ok, rules} = KnowledgeGraph.query_applicable_rules(code_type)
    
    # Build constraint section
    constraints = build_constraint_prompt(rules)
    
    # Inject into prompt
    """
    #{prompt}
    
    ## Code Quality Requirements
    
    You MUST follow these Elixir best practices. Violations will cause rejection:
    
    ### Critical (BLOCKING - code will be rejected):
    #{format_rules(rules, :critical)}
    
    ### High Priority (strongly avoid):
    #{format_rules(rules, :high)}
    
    ### Patterns to Avoid (with examples):
    #{format_negative_examples(rules)}
    
    ### Preferred Patterns (use these instead):
    #{format_positive_examples(rules)}
    """
  end
  
  defp analyze_code_type(prompt) do
    cond do
      String.contains?(prompt, ["GenServer", "handle_call", "handle_cast"]) ->
        [:otp, :genserver, :process]
      String.contains?(prompt, ["Supervisor", "child_spec"]) ->
        [:otp, :supervisor, :process]
      String.contains?(prompt, ["Ecto", "Repo", "schema"]) ->
        [:ecto, :database, :query]
      String.contains?(prompt, ["Phoenix", "controller", "view"]) ->
        [:phoenix, :web, :controller]
      String.contains?(prompt, ["LiveView", "handle_event"]) ->
        [:phoenix, :liveview, :web]
      true ->
        [:general]
    end
  end
end
```

### Strategy 2: Negative example injection

Providing explicit examples of what NOT to generate significantly improves LLM adherence to rules:

```elixir
defmodule JidoCode.PreGeneration.NegativeExamples do
  @security_examples %{
    sql_injection: """
    ❌ NEVER DO THIS (SQL Injection vulnerability):
    ```elixir
    def get_user(id) do
      query = "SELECT * FROM users WHERE id = '\#{id}'"
      Repo.query(query)
    end
    ```
    
    ✅ ALWAYS DO THIS (parameterized query):
    ```elixir
    def get_user(id) do
      from(u in User, where: u.id == ^id)
      |> Repo.one()
    end
    ```
    """,
    
    command_injection: """
    ❌ NEVER DO THIS (Command Injection):
    ```elixir
    def run_command(user_input) do
      System.cmd("sh", ["-c", "echo \#{user_input}"])
    end
    ```
    
    ✅ ALWAYS DO THIS (sanitized input):
    ```elixir
    def run_command(filename) when is_binary(filename) do
      sanitized = Path.basename(filename)  # Remove path components
      if sanitized =~ ~r/^[a-zA-Z0-9_.-]+$/ do
        System.cmd("cat", [sanitized], cd: "/safe/directory")
      else
        {:error, :invalid_filename}
      end
    end
    ```
    """
  }
  
  @process_examples %{
    unsupervised_process: """
    ❌ NEVER DO THIS (unsupervised process):
    ```elixir
    def start_worker(args) do
      spawn(fn -> do_work(args) end)
    end
    ```
    
    ✅ ALWAYS DO THIS (supervised):
    ```elixir
    def start_worker(args) do
      DynamicSupervisor.start_child(
        MyApp.WorkerSupervisor,
        {MyApp.Worker, args}
      )
    end
    ```
    """,
    
    dynamic_atoms: """
    ❌ NEVER DO THIS (atom exhaustion risk):
    ```elixir
    def parse_status(status_string) do
      String.to_atom(status_string)
    end
    ```
    
    ✅ ALWAYS DO THIS (safe atom handling):
    ```elixir
    @valid_statuses ~w(pending active completed failed)a
    
    def parse_status(status_string) do
      case String.to_existing_atom(status_string) do
        status when status in @valid_statuses -> {:ok, status}
        _ -> {:error, :invalid_status}
      end
    rescue
      ArgumentError -> {:error, :unknown_status}
    end
    ```
    """
  }
  
  def get_examples_for_context(code_types) do
    examples = []
    
    examples = if :database in code_types or :query in code_types do
      [Map.get(@security_examples, :sql_injection) | examples]
    else
      examples
    end
    
    examples = if :process in code_types or :otp in code_types do
      examples ++ [
        Map.get(@process_examples, :unsupervised_process),
        Map.get(@process_examples, :dynamic_atoms)
      ]
    else
      examples
    end
    
    Enum.join(examples, "\n\n")
  end
end
```

### Strategy 3: SPARQL-driven contextual rules

Query the knowledge graph for rules specifically applicable to the detected code patterns:

```elixir
defmodule JidoCode.PreGeneration.SPARQLConstraints do
  @applicable_rules_query """
  PREFIX val: <http://jidocode.dev/ontology/validation#>
  PREFIX elx: <http://jidocode.dev/ontology/elixir#>
  
  SELECT ?rule ?description ?severity ?negExample ?posExample ?remediation
  WHERE {
    ?rule a/rdfs:subClassOf* val:ValidationRule .
    ?rule val:applicableTo ?codeType .
    FILTER(?codeType IN (<%= code_types %>))
    
    ?rule rdfs:comment ?description .
    ?rule val:hasSeverity/rdfs:label ?severity .
    
    OPTIONAL { ?rule val:hasNegativeExample ?negExample }
    OPTIONAL { ?rule val:hasPositiveExample ?posExample }
    OPTIONAL { ?rule val:hasRemediation ?remediation }
  }
  ORDER BY DESC(?severity)
  """
  
  def fetch_constraints(code_types, sparql_client) do
    code_type_uris = Enum.map(code_types, &"elx:#{&1}")
    query = EEx.eval_string(@applicable_rules_query, code_types: Enum.join(code_type_uris, ", "))
    
    case SPARQL.Client.query(query, sparql_client) do
      {:ok, results} -> format_as_prompt_section(results)
      {:error, _} -> default_constraints()
    end
  end
end
```

## Violation scoring and best-attempt selection algorithm

The scoring algorithm enables intelligent comparison across attempts, selecting the best result even when perfection isn't achieved.

```elixir
defmodule JidoCode.Validation.ViolationScorer do
  @moduledoc """
  Unified scoring algorithm for violations across all three domains.
  Enables intelligent comparison and selection of best attempt.
  """
  
  @severity_weights %{
    critical: 100,
    high: 50,
    medium: 20,
    low: 5,
    info: 1
  }
  
  @domain_multipliers %{
    security: 2.0,      # Security issues weighted highest
    anti_pattern: 1.2,  # Anti-patterns moderately weighted
    credo: 1.0          # Credo rules baseline
  }
  
  @type violation :: %{
    domain: :security | :anti_pattern | :credo,
    severity: :critical | :high | :medium | :low | :info,
    rule_id: String.t(),
    message: String.t(),
    location: map(),
    blocking: boolean()
  }
  
  @type attempt_result :: %{
    code: String.t(),
    violations: [violation()],
    score: float(),
    blocking_count: non_neg_integer(),
    attempt_number: pos_integer()
  }
  
  @doc """
  Calculate weighted violation score for a code attempt.
  Lower scores are better (0 = perfect).
  """
  @spec calculate_score([violation()]) :: {float(), non_neg_integer()}
  def calculate_score(violations) do
    {total_score, blocking_count} =
      Enum.reduce(violations, {0.0, 0}, fn violation, {score, blocking} ->
        base_weight = Map.get(@severity_weights, violation.severity, 10)
        domain_mult = Map.get(@domain_multipliers, violation.domain, 1.0)
        
        violation_score = base_weight * domain_mult
        new_blocking = if violation.blocking, do: blocking + 1, else: blocking
        
        {score + violation_score, new_blocking}
      end)
    
    # Apply diminishing returns for repeated violations of same type
    adjusted_score = apply_diminishing_returns(violations, total_score)
    
    {adjusted_score, blocking_count}
  end
  
  @doc """
  Select best attempt from multiple generation attempts.
  Prioritizes: no blocking violations > lowest score > fewest violations
  """
  @spec select_best_attempt([attempt_result()]) :: attempt_result()
  def select_best_attempt(attempts) do
    attempts
    |> Enum.sort_by(fn attempt ->
      # Primary: blocking count (lower is better)
      # Secondary: weighted score (lower is better)  
      # Tertiary: total violations (lower is better)
      {attempt.blocking_count, attempt.score, length(attempt.violations)}
    end)
    |> List.first()
  end
  
  @doc """
  Determine if retry should be attempted based on current state.
  """
  @spec should_retry?(attempt_result(), config :: map()) :: boolean()
  def should_retry?(attempt, config) do
    cond do
      # Perfect score - no retry needed
      attempt.score == 0.0 ->
        false
      
      # Max attempts reached
      attempt.attempt_number >= config.max_retries ->
        false
      
      # Only blocking violations remaining and score not improving
      attempt.blocking_count > 0 ->
        true
      
      # Score above acceptable threshold
      attempt.score > config.acceptable_score_threshold ->
        true
      
      # Otherwise don't retry
      true ->
        false
    end
  end
  
  # Apply diminishing returns for repeated violations
  defp apply_diminishing_returns(violations, base_score) do
    violation_counts = Enum.frequencies_by(violations, & &1.rule_id)
    
    Enum.reduce(violation_counts, base_score, fn {_rule, count}, score ->
      if count > 1 do
        # Each additional violation of same type counts less
        reduction = :math.log(count) * 5
        score - reduction
      else
        score
      end
    end)
    |> max(0.0)
  end
end
```

### Attempt tracking and comparison

```elixir
defmodule JidoCode.Validation.AttemptTracker do
  @moduledoc """
  Tracks all generation attempts and their violations for comparison.
  """
  
  use Agent
  
  defstruct [
    :request_id,
    :original_prompt,
    attempts: [],
    best_attempt: nil,
    started_at: nil,
    config: %{}
  ]
  
  def start_link(request_id, prompt, config) do
    Agent.start_link(fn ->
      %__MODULE__{
        request_id: request_id,
        original_prompt: prompt,
        started_at: DateTime.utc_now(),
        config: config
      }
    end, name: via_tuple(request_id))
  end
  
  def record_attempt(request_id, code, violations) do
    Agent.update(via_tuple(request_id), fn state ->
      {score, blocking_count} = ViolationScorer.calculate_score(violations)
      
      attempt = %{
        code: code,
        violations: violations,
        score: score,
        blocking_count: blocking_count,
        attempt_number: length(state.attempts) + 1,
        timestamp: DateTime.utc_now()
      }
      
      new_attempts = state.attempts ++ [attempt]
      best = ViolationScorer.select_best_attempt(new_attempts)
      
      %{state | attempts: new_attempts, best_attempt: best}
    end)
  end
  
  def get_best_attempt(request_id) do
    Agent.get(via_tuple(request_id), & &1.best_attempt)
  end
  
  def get_summary(request_id) do
    Agent.get(via_tuple(request_id), fn state ->
      %{
        total_attempts: length(state.attempts),
        best_score: state.best_attempt && state.best_attempt.score,
        improvement_trend: calculate_trend(state.attempts),
        violations_by_domain: group_violations_by_domain(state.best_attempt)
      }
    end)
  end
  
  defp via_tuple(request_id), do: {:via, Registry, {JidoCode.AttemptRegistry, request_id}}
  
  defp calculate_trend(attempts) when length(attempts) < 2, do: :insufficient_data
  defp calculate_trend(attempts) do
    scores = Enum.map(attempts, & &1.score)
    if List.last(scores) < List.first(scores), do: :improving, else: :degrading
  end
end
```

## Elixir middleware design using Jido Skills

The middleware integrates as a Jido Skill that wraps the LLM code generation workflow:

```elixir
defmodule JidoCode.Skills.ValidationMiddleware do
  @moduledoc """
  Validation middleware skill that wraps LLM code generation with
  pre-generation constraint injection and post-generation validation.
  """
  
  use Jido.Skill,
    name: "validation_middleware",
    description: "Unified code validation pipeline for JidoCode"
  
  alias JidoCode.PreGeneration.ConstraintInjector
  alias JidoCode.Validation.{ParallelValidator, ViolationScorer, AttemptTracker}
  alias JidoCode.Actions.{GenerateCode, ValidateCredo, ValidateAntiPatterns, ValidateSecurity}
  
  @impl Jido.Skill
  def mount(agent, opts) do
    config = Keyword.get(opts, :config, default_config())
    
    # Register validation actions
    Jido.Agent.register_action(agent, [
      ValidateCredo,
      ValidateAntiPatterns,
      ValidateSecurity,
      JidoCode.Actions.AggregateViolations
    ])
    
    {:ok, agent, %{config: config}}
  end
  
  @impl Jido.Skill
  def router(_opts) do
    [
      {"jidocode.generate", &handle_generate/2},
      {"jidocode.validate", &handle_validate/2}
    ]
  end
  
  @impl Jido.Skill
  def handle_signal(%{type: "jidocode.generate"} = signal, skill_opts) do
    request_id = signal.id || UUID.uuid4()
    config = skill_opts.config
    
    # Start tracking attempts
    {:ok, _} = AttemptTracker.start_link(request_id, signal.data.prompt, config)
    
    # Run generation with validation loop
    result = generate_with_validation_loop(signal.data, config, request_id)
    
    {:ok, %{signal | data: result}}
  end
  
  defp generate_with_validation_loop(input, config, request_id, attempt \\ 1) do
    # STAGE 1: Pre-generation constraint injection
    enriched_prompt = ConstraintInjector.inject_constraints(
      input.prompt,
      input[:context] || %{}
    )
    
    # STAGE 2: Generate code via LLM
    {:ok, generated} = generate_code(enriched_prompt, config.model)
    
    # STAGE 3: Parallel validation
    violations = ParallelValidator.validate_all(
      generated.code,
      config.enabled_domains
    )
    
    # Record this attempt
    AttemptTracker.record_attempt(request_id, generated.code, violations)
    best = AttemptTracker.get_best_attempt(request_id)
    
    # STAGE 4: Decision
    cond do
      # Perfect - return immediately
      best.score == 0.0 ->
        build_success_result(best)
      
      # Check if should retry
      ViolationScorer.should_retry?(best, config) and attempt < config.max_retries ->
        # Build feedback for retry
        feedback_prompt = build_feedback_prompt(input.prompt, violations)
        generate_with_validation_loop(
          %{input | prompt: feedback_prompt},
          config,
          request_id,
          attempt + 1
        )
      
      # Return best attempt with report
      true ->
        build_result_with_report(best, request_id)
    end
  end
  
  defp build_feedback_prompt(original_prompt, violations) do
    violation_feedback = format_violations_for_llm(violations)
    
    """
    Your previous code had the following issues that MUST be fixed:
    
    #{violation_feedback}
    
    Please regenerate the code addressing ALL of these issues:
    
    #{original_prompt}
    """
  end
  
  defp format_violations_for_llm(violations) do
    violations
    |> Enum.group_by(& &1.domain)
    |> Enum.map(fn {domain, domain_violations} ->
      """
      ## #{String.capitalize(to_string(domain))} Issues:
      #{Enum.map_join(domain_violations, "\n", fn v ->
        "- [#{v.severity}] #{v.message} at #{format_location(v.location)}"
      end)}
      """
    end)
    |> Enum.join("\n\n")
  end
  
  defp default_config do
    %{
      max_retries: 3,
      acceptable_score_threshold: 50.0,
      enabled_domains: [:credo, :anti_pattern, :security],
      model: {:anthropic, model: "claude-sonnet-4-20250514"},
      parallel_validation: true,
      timeout_ms: 30_000
    }
  end
end
```

### Parallel validation execution

```elixir
defmodule JidoCode.Validation.ParallelValidator do
  @moduledoc """
  Executes all three validation domains in parallel for efficiency.
  """
  
  alias JidoCode.Validators.{CredoValidator, AntiPatternValidator, SecurityValidator}
  
  @validators %{
    credo: CredoValidator,
    anti_pattern: AntiPatternValidator,
    security: SecurityValidator
  }
  
  @doc """
  Run all enabled validators in parallel and aggregate results.
  """
  def validate_all(code, enabled_domains, opts \\ []) do
    timeout = Keyword.get(opts, :timeout, 30_000)
    
    enabled_domains
    |> Enum.filter(&Map.has_key?(@validators, &1))
    |> Task.async_stream(
      fn domain ->
        validator = Map.fetch!(@validators, domain)
        {domain, validator.validate(code)}
      end,
      timeout: timeout,
      on_timeout: :kill_task
    )
    |> Enum.flat_map(fn
      {:ok, {domain, {:ok, violations}}} ->
        Enum.map(violations, &Map.put(&1, :domain, domain))
      
      {:ok, {domain, {:error, reason}}} ->
        [%{domain: domain, severity: :info, message: "Validator error: #{reason}", blocking: false}]
      
      {:exit, :timeout} ->
        [%{domain: :system, severity: :info, message: "Validation timeout", blocking: false}]
    end)
    |> Enum.sort_by(&severity_order(&1.severity))
  end
  
  defp severity_order(:critical), do: 0
  defp severity_order(:high), do: 1
  defp severity_order(:medium), do: 2
  defp severity_order(:low), do: 3
  defp severity_order(:info), do: 4
  defp severity_order(_), do: 5
end
```

## Configuration schema for the pipeline

The configuration schema uses NimbleOptions for validation:

```elixir
defmodule JidoCode.Validation.Config do
  @moduledoc """
  Configuration schema for the validation pipeline.
  """
  
  @schema [
    # Retry configuration
    max_retries: [
      type: :non_neg_integer,
      default: 3,
      doc: "Maximum number of generation attempts before returning best result"
    ],
    
    acceptable_score_threshold: [
      type: :float,
      default: 50.0,
      doc: "Score below which code is accepted without retry (0 = perfect)"
    ],
    
    # Domain enablement
    enabled_domains: [
      type: {:list, {:in, [:credo, :anti_pattern, :security]}},
      default: [:credo, :anti_pattern, :security],
      doc: "Which validation domains to enable"
    ],
    
    # Domain-specific configuration
    credo: [
      type: :keyword_list,
      default: [],
      doc: "Credo-specific configuration",
      keys: [
        config_file: [type: :string, doc: "Path to .credo.exs"],
        strict: [type: :boolean, default: false],
        enabled_checks: [type: {:list, :atom}, default: []]
      ]
    ],
    
    anti_pattern: [
      type: :keyword_list,
      default: [],
      doc: "Anti-pattern detection configuration",
      keys: [
        ignore_patterns: [type: {:list, :atom}, default: []],
        custom_patterns: [type: {:list, :any}, default: []]
      ]
    ],
    
    security: [
      type: :keyword_list,
      default: [],
      doc: "Security validation configuration",
      keys: [
        sobelow_config: [type: :string],
        ignore_vulnerabilities: [type: {:list, :atom}, default: []],
        scan_dependencies: [type: :boolean, default: true]
      ]
    ],
    
    # Severity configuration
    severity_overrides: [
      type: {:map, :atom, {:in, [:critical, :high, :medium, :low, :info]}},
      default: %{},
      doc: "Override default severity for specific rules"
    ],
    
    blocking_severities: [
      type: {:list, {:in, [:critical, :high, :medium, :low, :info]}},
      default: [:critical, :high],
      doc: "Severity levels that block code acceptance"
    ],
    
    # SPARQL configuration
    sparql: [
      type: :keyword_list,
      default: [],
      doc: "SPARQL/knowledge graph configuration",
      keys: [
        endpoint: [type: :string, doc: "SPARQL endpoint URL"],
        timeout_ms: [type: :pos_integer, default: 5000],
        use_local_graph: [type: :boolean, default: true]
      ]
    ],
    
    # LLM configuration
    model: [
      type: {:or, [:atom, :tuple]},
      default: {:anthropic, [model: "claude-sonnet-4-20250514"]},
      doc: "LLM model configuration for code generation"
    ],
    
    # Execution configuration
    parallel_validation: [
      type: :boolean,
      default: true,
      doc: "Run validators in parallel vs sequential"
    ],
    
    timeout_ms: [
      type: :pos_integer,
      default: 30_000,
      doc: "Total timeout for validation pipeline"
    ],
    
    # Telemetry
    emit_telemetry: [
      type: :boolean,
      default: true,
      doc: "Emit telemetry events for monitoring"
    ]
  ]
  
  def schema, do: @schema
  
  def validate!(opts) do
    NimbleOptions.validate!(opts, @schema)
  end
  
  def default_config do
    NimbleOptions.validate!([], @schema)
  end
end
```

### Example configuration usage

```elixir
# In application config
config :jido_code, :validation,
  max_retries: 5,
  acceptable_score_threshold: 30.0,
  enabled_domains: [:credo, :security],  # Skip anti-pattern for speed
  
  blocking_severities: [:critical],  # Only block on critical
  
  severity_overrides: %{
    # Treat unsupervised processes as critical
    unsupervised_process: :critical,
    # Downgrade certain credo rules
    module_doc: :info
  },
  
  security: [
    ignore_vulnerabilities: [:csrf],  # Handled by framework
    scan_dependencies: false
  ],
  
  sparql: [
    endpoint: "http://localhost:3030/jidocode/query",
    use_local_graph: true
  ],
  
  model: {:anthropic, [
    model: "claude-sonnet-4-20250514",
    temperature: 0.3,
    max_tokens: 4096
  ]}
```

## Complete implementation example

```elixir
defmodule JidoCode.Actions.GenerateValidatedCode do
  @moduledoc """
  Complete action for generating validated Elixir code.
  """
  
  use Jido.Action,
    name: "generate_validated_code",
    description: "Generates Elixir code with full validation pipeline",
    schema: [
      prompt: [type: :string, required: true],
      context: [type: :map, default: %{}],
      config_overrides: [type: :map, default: %{}]
    ]
  
  alias JidoCode.Validation.{Config, ParallelValidator, ViolationScorer, AttemptTracker}
  alias JidoCode.PreGeneration.ConstraintInjector
  
  @impl true
  def run(params, context) do
    config = build_config(params.config_overrides, context)
    request_id = UUID.uuid4()
    
    with {:ok, _} <- AttemptTracker.start_link(request_id, params.prompt, config),
         {:ok, result} <- execute_pipeline(params, config, request_id) do
      {:ok, result}
    end
  end
  
  defp execute_pipeline(params, config, request_id, attempt \\ 1) do
    # Pre-generation
    enriched = ConstraintInjector.inject_constraints(params.prompt, params.context)
    
    # Generation
    {:ok, code} = generate_with_llm(enriched, config.model)
    
    # Validation
    violations = ParallelValidator.validate_all(code, config.enabled_domains)
    
    # Record and evaluate
    AttemptTracker.record_attempt(request_id, code, violations)
    best = AttemptTracker.get_best_attempt(request_id)
    
    if should_continue?(best, config, attempt) do
      feedback_params = %{params | prompt: build_feedback(params.prompt, violations)}
      execute_pipeline(feedback_params, config, request_id, attempt + 1)
    else
      build_final_result(best, request_id, config)
    end
  end
  
  defp should_continue?(best, config, attempt) do
    best.score > 0 and 
    best.blocking_count > 0 and 
    attempt < config.max_retries
  end
  
  defp build_final_result(best, request_id, config) do
    summary = AttemptTracker.get_summary(request_id)
    
    %{
      code: best.code,
      accepted: best.blocking_count == 0,
      score: best.score,
      attempts: summary.total_attempts,
      violations: format_violation_report(best.violations),
      metadata: %{
        request_id: request_id,
        improvement_trend: summary.improvement_trend,
        domains_checked: config.enabled_domains
      }
    }
  end
  
  defp format_violation_report(violations) do
    violations
    |> Enum.group_by(& &1.domain)
    |> Enum.map(fn {domain, vs} ->
      {domain, %{
        count: length(vs),
        blocking: Enum.count(vs, & &1.blocking),
        items: Enum.map(vs, &Map.take(&1, [:severity, :message, :location, :rule_id]))
      }}
    end)
    |> Map.new()
  end
end
```

## Key design decisions and tradeoffs

**Parallel vs sequential validation**: The design defaults to parallel execution using Task.async_stream, reducing total validation time from ~3x (sequential) to ~1x (parallel, limited by slowest validator). Sequential mode is available for debugging.

**Skill-based middleware**: Rather than introducing a new middleware abstraction, the design leverages Jido's existing Skill primitive. Skills provide signal routing, action registration, and lifecycle hooks—everything needed for middleware functionality without framework modifications.

**SPARQL for rule retrieval, not runtime validation**: Complex pattern matching happens at the SPARQL level during pre-generation (selecting applicable rules) and post-generation analysis (building code representations). Runtime validation uses Elixir pattern matching on AST for performance.

**Diminishing returns in scoring**: Repeated violations of the same rule contribute progressively less to the score. This prevents a single frequently-violated rule from dominating the score and encourages the LLM to address diverse issues.

**Best-attempt selection over hard failure**: The system always returns usable code, even when violations remain. This pragmatic approach acknowledges that LLMs cannot achieve perfection on every generation, while still maximizing code quality through the retry loop.

The architecture supports future extension to additional validation domains (testing, documentation, performance) by implementing new validators that conform to the same interface and registering them in the parallel validator's domain map.
