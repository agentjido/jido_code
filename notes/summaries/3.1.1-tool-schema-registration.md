# Summary: 3.1.1 Tool Schema and Registration

## Overview

Implemented the tool schema and registry system that enables the LLM agent to discover and invoke tools for interacting with the codebase.

## Components Implemented

### 1. JidoCode.Tools.Param (`lib/jido_code/tools/param.ex`)

Parameter schema struct for defining tool inputs:

- **Fields**: name, type, description, required, default, items, properties, enum
- **Supported types**: string, integer, number, boolean, array, object
- **Validation**: Type checking, required fields, nested property validation
- **LLM format**: `to_json_schema/1` generates OpenAI-compatible JSON Schema

```elixir
{:ok, param} = Param.new(%{
  name: "path",
  type: :string,
  description: "File path to read",
  required: true
})
```

### 2. JidoCode.Tools.Tool (`lib/jido_code/tools/tool.ex`)

Tool definition struct with handler module reference:

- **Fields**: name, description, parameters, handler
- **Validation**: Name format (lowercase, underscores), handler must be module atom
- **LLM format**: `to_llm_function/1` generates OpenAI function calling spec
- **Argument validation**: `validate_args/2` checks required params, types, unknowns

```elixir
{:ok, tool} = Tool.new(%{
  name: "read_file",
  description: "Read the contents of a file",
  handler: JidoCode.Tools.Handlers.ReadFile,
  parameters: [
    %{name: "path", type: :string, description: "File path"}
  ]
})
```

### 3. JidoCode.Tools.Registry (`lib/jido_code/tools/registry.ex`)

GenServer registry with ETS backing for fast concurrent reads:

- **Register**: `register/1` - adds tool, rejects duplicates
- **Unregister**: `unregister/1` - removes tool by name
- **Lookup**: `get/1` - finds tool by name
- **List**: `list/0` - returns all tools sorted by name
- **Count**: `count/0` - returns number of registered tools
- **LLM format**: `to_llm_format/0` - all tools as OpenAI function specs
- **Text format**: `to_text_description/0` - human-readable tool list

### 4. JidoCode.Tools (`lib/jido_code/tools.ex`)

Namespace module with convenience delegations:

- `new_param/1`, `new_tool/1` - constructors
- `register/1`, `list_tools/0`, `get_tool/1`, `to_llm_format/0` - registry ops

## Supervision

Registry added to application supervision tree in `JidoCode.Application`:

```elixir
children = [
  JidoCode.Settings.Cache,
  {Phoenix.PubSub, name: JidoCode.PubSub},
  {Registry, keys: :unique, name: JidoCode.AgentRegistry},
  JidoCode.Tools.Registry,  # NEW
  JidoCode.AgentSupervisor
]
```

## Test Coverage

76 new tests across 3 test files:

- `test/jido_code/tools/param_test.exs` - 23 tests
- `test/jido_code/tools/tool_test.exs` - 33 tests
- `test/jido_code/tools/registry_test.exs` - 20 tests

Total suite: 383 tests passing (up from 316)

## Files Changed

**New files:**
- `lib/jido_code/tools.ex`
- `lib/jido_code/tools/param.ex`
- `lib/jido_code/tools/tool.ex`
- `lib/jido_code/tools/registry.ex`
- `test/jido_code/tools/param_test.exs`
- `test/jido_code/tools/tool_test.exs`
- `test/jido_code/tools/registry_test.exs`
- `notes/features/3.1.1-tool-schema-registration.md`

**Modified files:**
- `lib/jido_code/application.ex` - added Registry to supervision
- `test/jido_code/application_test.exs` - updated child count assertion
- `notes/planning/proof-of-concept/phase-03.md` - marked task complete

## Usage Example

```elixir
# Register a tool at application startup
{:ok, tool} = JidoCode.Tools.new_tool(%{
  name: "read_file",
  description: "Read file contents from the project directory",
  handler: JidoCode.Tools.Handlers.ReadFile,
  parameters: [
    %{name: "path", type: :string, description: "Relative file path", required: true},
    %{name: "encoding", type: :string, description: "File encoding", required: false, default: "utf-8"}
  ]
})

:ok = JidoCode.Tools.register(tool)

# Get LLM function format for system prompt
functions = JidoCode.Tools.to_llm_format()
# => [%{type: "function", function: %{name: "read_file", ...}}]

# Look up tool for execution
{:ok, tool} = JidoCode.Tools.get_tool("read_file")
```

## Next Steps

Task 3.1.2: Tool Execution Flow - Parse LLM tool calls, validate against schema, delegate to sandbox manager.
