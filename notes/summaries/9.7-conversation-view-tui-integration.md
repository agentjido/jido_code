# Summary: ConversationView TUI Integration (Phase 9.7)

## Overview

Integrated the ConversationView widget into the main TUI application. This involved adding the widget state to the TUI Model, routing scroll and mouse events to ConversationView, updating message handlers to sync with ConversationView during streaming, and handling viewport resize.

## Changes Made

### Files Modified

- **`lib/jido_code/tui.ex`** - Core TUI integration
  - Added `conversation_view: map() | nil` field to Model type and struct
  - Updated `init/1` to initialize ConversationView with viewport dimensions
  - Changed event routing from `{:scroll, :up/down}` to `{:conversation_event, event}`
  - Added mouse event routing to ConversationView
  - Added `update({:conversation_event, event}, state)` handler
  - Updated resize handler to call `ConversationView.set_viewport_size/3`
  - Added `render_conversation_area/1` helper using `ConversationView.render/1`
  - Added `generate_message_id/0` helper
  - Updated `do_dispatch_to_agent/2`, `do_handle_command/2`, `do_show_config_error/2` to sync messages to ConversationView

- **`lib/jido_code/tui/message_handlers.ex`** - Streaming synchronization
  - Added ConversationView alias
  - Updated `handle_stream_chunk/2` to call `start_streaming/2` and `append_chunk/2`
  - Updated `handle_stream_end/2` to call `end_streaming/1`
  - Updated `handle_stream_error/2` to add error message to ConversationView
  - Added `generate_message_id/0` helper

- **`lib/jido_code/tui/widgets/conversation_view.ex`** - New function
  - Added `set_viewport_size/3` to update viewport dimensions and recalculate layout

- **`test/jido_code/tui_test.exs`** - Updated scroll tests
  - Updated scroll navigation tests to expect `{:conversation_event, event}` instead of `{:scroll, :up/down}`
  - Added integration tests for conversation_event delegation to ConversationView

- **`notes/planning/proof-of-concept/phase-09.md`** - Marked all 9.7 tasks complete

- **`notes/features/conversation-view-integration.md`** - Feature planning document

## Technical Implementation

### Model Integration

```elixir
@type t :: %Model{
  # ... existing fields ...
  conversation_view: map() | nil
}

defstruct [
  # ... existing fields ...
  conversation_view: nil
]
```

### Initialization

```elixir
def init(opts) do
  # Calculate conversation area dimensions
  {width, height} = Map.get(opts, :window, {80, 24})
  conversation_width = width - 2  # Padding
  conversation_height = height - 6  # Header, input, status

  # Initialize ConversationView
  conversation_view_props = ConversationView.new(
    messages: [],
    viewport_width: conversation_width,
    viewport_height: conversation_height
  )
  conversation_view_state = ConversationView.init(conversation_view_props)

  %Model{
    # ... other fields ...
    conversation_view: conversation_view_state
  }
end
```

### Event Routing

Changed from direct scroll handling to ConversationView delegation:

```elixir
# Before
def event_to_msg(%Event.Key{key: :up}, _state), do: {:msg, {:scroll, :up}}
def event_to_msg(%Event.Key{key: :down}, _state), do: {:msg, {:scroll, :down}}

# After
def event_to_msg(%Event.Key{key: key} = event, state)
    when key in [:up, :down, :page_up, :page_down, :home, :end] do
  cond do
    state.pick_list -> {:msg, {:pick_list_event, event}}
    state.shell_dialog -> {:msg, {:input_event, event}}
    true -> {:msg, {:conversation_event, event}}
  end
end
```

### Event Handler

```elixir
def update({:conversation_event, event}, state) when state.conversation_view != nil do
  case ConversationView.handle_event(event, state.conversation_view) do
    {:ok, new_conversation_view} ->
      {%{state | conversation_view: new_conversation_view}, []}
    _ ->
      {state, []}
  end
end
```

### Viewport Resize

New function in ConversationView:

```elixir
@spec set_viewport_size(state(), pos_integer(), pos_integer()) :: state()
def set_viewport_size(state, width, height) do
  new_total_lines = calculate_total_lines(
    state.messages, state.max_collapsed_lines, state.expanded, width
  )
  max_offset = max(0, new_total_lines - height)
  new_offset = min(state.scroll_offset, max_offset)

  %{state |
    viewport_width: width,
    viewport_height: height,
    total_lines: new_total_lines,
    scroll_offset: new_offset
  }
end
```

### Streaming Synchronization

Message handlers now sync with ConversationView during streaming:

```elixir
def handle_stream_chunk(chunk, state) do
  # Start streaming if first chunk
  cv_state = if state.streaming_message == nil do
    {cv, _id} = ConversationView.start_streaming(state.conversation_view, :assistant)
    cv
  else
    state.conversation_view
  end

  # Append the chunk
  new_conversation_view = ConversationView.append_chunk(cv_state, chunk)

  %{state |
    streaming_message: (state.streaming_message || "") <> chunk,
    conversation_view: new_conversation_view
  }
end
```

## Test Coverage

Updated existing scroll navigation tests to work with new architecture:

- `up arrow returns {:msg, {:conversation_event, event}}`
- `down arrow returns {:msg, {:conversation_event, event}}`
- `page up returns {:msg, {:conversation_event, event}}`
- `page down returns {:msg, {:conversation_event, event}}`
- `home returns {:msg, {:conversation_event, event}}`
- `end returns {:msg, {:conversation_event, event}}`
- `conversation_event delegates to ConversationView.handle_event`
- `conversation_event handles scroll_down`
- `conversation_event handles scroll_up`

## Branch

`feature/conversation-view-integration`

## Notes

- The old `render_conversation_area/1` in ViewHelpers is kept as fallback when `conversation_view` is nil
- Message synchronization happens in both TUI and MessageHandlers modules
- The 12 pre-existing test failures are unrelated to this integration work
- All 173 ConversationView-specific tests pass
